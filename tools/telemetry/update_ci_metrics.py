from __future__ import annotations

import argparse
from datetime import UTC, datetime
from pathlib import Path
from typing import Sequence

from .ci_metrics import (
    DEFAULT_METRICS_PATH,
    record_coverage,
    record_coverage_domains,
    record_formatter,
    record_remediation,
)


def _timestamp() -> str:
    return datetime.now(tz=UTC).isoformat(timespec="seconds")


def _build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description=(
            "Update CI telemetry trendlines for coverage, formatter adoption, and remediation progress."
        ),
    )
    parser.add_argument(
        "--metrics",
        type=Path,
        default=DEFAULT_METRICS_PATH,
        help="Path to the CI metrics JSON file (defaults to tests/.telemetry/ci_metrics.json)",
    )
    parser.add_argument(
        "--coverage-report",
        type=Path,
        help="Path to a coverage XML report generated by coverage.py/pytest --cov",
    )
    parser.add_argument(
        "--coverage-label",
        type=str,
        help="Label to associate with the recorded coverage entry (defaults to UTC timestamp)",
    )
    parser.add_argument(
        "--no-domain-breakdown",
        action="store_true",
        help="Skip recording per-domain coverage snapshots when recording coverage",
    )
    parser.add_argument(
        "--domain-threshold",
        type=float,
        default=80.0,
        help="Threshold for flagging lagging domains in coverage telemetry",
    )
    parser.add_argument(
        "--allowlist",
        type=Path,
        help="Path to the Ruff formatter allowlist file (deprecated once formatter mode is global)",
    )
    parser.add_argument(
        "--formatter-mode",
        choices=["global", "allowlist"],
        help="Record a formatter trend entry using the specified enforcement mode",
    )
    parser.add_argument(
        "--formatter-label",
        type=str,
        help="Label for the formatter trend entry (defaults to UTC timestamp)",
    )
    parser.add_argument(
        "--remediation-status",
        action="append",
        metavar="KEY=VALUE",
        help=(
            "Record a remediation status entry in the telemetry JSON; "
            "specify multiple times for additional key/value pairs"
        ),
    )
    parser.add_argument(
        "--remediation-label",
        type=str,
        help="Label for the remediation progress entry (defaults to UTC timestamp)",
    )
    parser.add_argument(
        "--remediation-source",
        type=str,
        help="Optional evidence reference (URL or file path) for the remediation entry",
    )
    parser.add_argument(
        "--remediation-note",
        type=str,
        help="Optional free-form note to include with the remediation entry",
    )
    return parser


def _parse_status_arguments(entries: Sequence[str] | None) -> dict[str, str]:
    statuses: dict[str, str] = {}
    if not entries:
        return statuses
    for raw_entry in entries:
        if "=" not in raw_entry:
            raise ValueError(f"Invalid remediation status entry: {raw_entry!r}")
        key, value = raw_entry.split("=", 1)
        key = key.strip()
        value = value.strip()
        if not key or not value:
            raise ValueError(f"Invalid remediation status entry: {raw_entry!r}")
        statuses[key] = value
    return statuses


def main(argv: Sequence[str] | None = None) -> int:
    parser = _build_parser()
    args = parser.parse_args(argv)

    formatter_mode: str | None = args.formatter_mode
    if formatter_mode is None and args.allowlist is not None:
        formatter_mode = "allowlist"

    remediation_statuses: dict[str, str] = {}
    try:
        remediation_statuses = _parse_status_arguments(args.remediation_status)
    except ValueError as exc:
        parser.error(str(exc))

    if (
        args.coverage_report is None
        and formatter_mode is None
        and not remediation_statuses
    ):
        parser.error(
            "Provide --coverage-report, --formatter-mode, --remediation-status, or a combination to update metrics"
        )

    if not remediation_statuses and (
        args.remediation_label is not None
        or args.remediation_source is not None
        or args.remediation_note is not None
    ):
        parser.error("--remediation-label/source/note require at least one --remediation-status entry")

    metrics_data = None
    metrics_path: Path = args.metrics

    if args.coverage_report is not None:
        coverage_label = args.coverage_label or _timestamp()
        metrics_data = record_coverage(
            metrics_path,
            args.coverage_report,
            label=coverage_label,
            data=metrics_data,
        )
        if not args.no_domain_breakdown:
            metrics_data = record_coverage_domains(
                metrics_path,
                args.coverage_report,
                label=coverage_label,
                threshold=args.domain_threshold,
                data=metrics_data,
            )

    if formatter_mode is not None:
        if formatter_mode == "allowlist" and args.allowlist is None:
            parser.error("--allowlist is required when --formatter-mode=allowlist")
        if formatter_mode != "allowlist" and args.allowlist is not None:
            parser.error("Do not supply --allowlist when formatter mode is global")

        formatter_label = args.formatter_label or _timestamp()
        metrics_data = record_formatter(
            metrics_path,
            args.allowlist if formatter_mode == "allowlist" else None,
            mode=formatter_mode,
            label=formatter_label,
            data=metrics_data,
        )

    if remediation_statuses:
        remediation_label = args.remediation_label or _timestamp()
        metrics_data = record_remediation(
            metrics_path,
            statuses=remediation_statuses,
            label=remediation_label,
            source=args.remediation_source,
            note=args.remediation_note,
            data=metrics_data,
        )

    return 0


if __name__ == "__main__":  # pragma: no cover - CLI entry point
    raise SystemExit(main())
