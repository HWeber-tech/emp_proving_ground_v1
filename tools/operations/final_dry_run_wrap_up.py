#!/usr/bin/env python3
"""Generate wrap-up artefacts for the AlphaTrade final dry run."""

from __future__ import annotations

import argparse
import json
from datetime import timedelta
from pathlib import Path
from typing import Sequence

from src.operations.dry_run_audit import DryRunStatus
from src.operations.final_dry_run_wrap_up import build_wrap_up_report


def _build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description=(
            "Produce wrap-up minutes and backlog entries from a final dry run "
            "summary bundle generated by the orchestrator."
        )
    )
    parser.add_argument(
        "summary",
        type=Path,
        help="Path to the summary JSON bundle emitted by the final dry run orchestrator.",
    )
    parser.add_argument(
        "--output-json",
        type=Path,
        help="Optional path for the wrap-up JSON report (default: alongside the summary file).",
    )
    parser.add_argument(
        "--output-markdown",
        type=Path,
        help="Optional path for the wrap-up Markdown minutes (default: alongside the summary file).",
    )
    parser.add_argument(
        "--no-json",
        action="store_true",
        help="Do not materialise the JSON report to disk.",
    )
    parser.add_argument(
        "--no-markdown",
        action="store_true",
        help="Do not materialise the Markdown minutes to disk.",
    )
    parser.add_argument(
        "--required-duration-hours",
        type=float,
        default=72.0,
        help=(
            "Target runtime duration in hours. Set to 0 to disable duration checks (default: 72)."
        ),
    )
    parser.add_argument(
        "--duration-tolerance-minutes",
        type=float,
        default=5.0,
        help="Allowance (minutes) below the target duration before flagging a failure (default: 5).",
    )
    parser.add_argument(
        "--treat-warn-as-failure",
        action="store_true",
        help="Escalate WARN severities to FAIL when computing the overall wrap-up status.",
    )
    return parser


def _load_summary(path: Path) -> dict:
    if not path.exists():
        raise SystemExit(f"Summary file does not exist: {path}")
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except json.JSONDecodeError as exc:  # pragma: no cover - defensive guard
        raise SystemExit(f"Failed to parse summary JSON: {exc}") from exc


def _determine_paths(
    summary_path: Path,
    output_json: Path | None,
    output_markdown: Path | None,
    *,
    emit_json: bool,
    emit_markdown: bool,
) -> tuple[Path | None, Path | None]:
    base_dir = summary_path.parent
    if emit_json:
        json_path = output_json or summary_path.with_name("wrap_up.json")
    else:
        json_path = None
    if emit_markdown:
        markdown_path = output_markdown or summary_path.with_name("wrap_up.md")
    else:
        markdown_path = None
    return json_path, markdown_path


def _ensure_positive(value: float, label: str) -> float:
    if value < 0:
        raise SystemExit(f"{label} must be non-negative (received {value})")
    return value


def main(argv: Sequence[str] | None = None) -> int:
    parser = _build_parser()
    args = parser.parse_args(argv)

    summary_path = args.summary
    bundle = _load_summary(summary_path)

    required_duration: timedelta | None
    if args.required_duration_hours <= 0:
        required_duration = None
    else:
        _ensure_positive(args.required_duration_hours, "--required-duration-hours")
        required_duration = timedelta(hours=args.required_duration_hours)

    tolerance_minutes = _ensure_positive(args.duration_tolerance_minutes, "--duration-tolerance-minutes")
    duration_tolerance = timedelta(minutes=tolerance_minutes)

    json_path, markdown_path = _determine_paths(
        summary_path,
        args.output_json,
        args.output_markdown,
        emit_json=not args.no_json,
        emit_markdown=not args.no_markdown,
    )

    report = build_wrap_up_report(
        bundle,
        required_duration=required_duration,
        duration_tolerance=duration_tolerance,
        treat_warn_as_failure=args.treat_warn_as_failure,
    )

    if json_path is not None:
        json_path.parent.mkdir(parents=True, exist_ok=True)
        json_path.write_text(json.dumps(report.as_dict(), indent=2), encoding="utf-8")

    if markdown_path is not None:
        markdown_path.parent.mkdir(parents=True, exist_ok=True)
        markdown_path.write_text(report.to_markdown(), encoding="utf-8")

    print(f"Wrap-up status: {report.status.value.upper()}")
    print(f"  Summary status: {report.summary_status.value.upper() if report.summary_status else 'N/A'}")
    print(f"  Sign-off status: {report.sign_off_status.value.upper() if report.sign_off_status else 'N/A'}")
    print(f"  Review status: {report.review_status.value.upper() if report.review_status else 'N/A'}")
    if report.duration_seconds is not None and report.duration_target_seconds is not None:
        observed_hours = report.duration_seconds / 3600.0
        target_hours = report.duration_target_seconds / 3600.0
        status = "met" if report.duration_met else "missed"
        print(
            f"  Duration {status}: observed {observed_hours:.2f}h / target {target_hours:.2f}h"
        )
    print(f"  Backlog items: {len(report.backlog_items)}")
    print(f"  Harness incidents: {len(report.incidents)}")

    if json_path is not None:
        print(f"  Wrap-up JSON: {json_path}")
    if markdown_path is not None:
        print(f"  Wrap-up Markdown: {markdown_path}")

    return 0 if report.status is not DryRunStatus.fail else 1


if __name__ == "__main__":  # pragma: no cover - CLI entry point
    raise SystemExit(main())

