"""End-to-end TRM exit drill that validates governance suggestion artefacts."""

from __future__ import annotations

import statistics
import time
from dataclasses import dataclass, field
from datetime import UTC, datetime
from enum import StrEnum
from pathlib import Path
from typing import Iterable, Mapping, MutableMapping, Sequence

import json

from jsonschema import Draft7Validator, RefResolver

from tools import rim_shadow_run


class TRMDrillStatus(StrEnum):
    """Status values recorded for each drill component and the overall run."""

    PASS = "pass"
    WARN = "warn"
    FAIL = "fail"


_STATUS_ORDER: Mapping[TRMDrillStatus, int] = {
    TRMDrillStatus.PASS: 0,
    TRMDrillStatus.WARN: 1,
    TRMDrillStatus.FAIL: 2,
}


@dataclass(frozen=True)
class TRMDrillComponent:
    """Structured status block for a single drill phase."""

    name: str
    status: TRMDrillStatus
    summary: str
    details: tuple[str, ...] = field(default_factory=tuple)

    def as_dict(self) -> MutableMapping[str, object]:
        return {
            "name": self.name,
            "status": self.status.value,
            "summary": self.summary,
            "details": list(self.details),
        }


@dataclass(frozen=True)
class TRMDrillMetrics:
    """Aggregated metrics derived from the generated suggestions."""

    suggestion_count: int
    types: Mapping[str, int]
    confidence_min: float | None
    confidence_avg: float | None
    confidence_max: float | None

    def as_dict(self) -> MutableMapping[str, object]:
        return {
            "suggestion_count": self.suggestion_count,
            "types": dict(self.types),
            "confidence_min": self.confidence_min,
            "confidence_avg": self.confidence_avg,
            "confidence_max": self.confidence_max,
        }


@dataclass(frozen=True)
class TRMDrillReport:
    """Full report generated by the TRM exit drill."""

    status: TRMDrillStatus
    generated_at: datetime
    components: tuple[TRMDrillComponent, ...]
    metrics: TRMDrillMetrics
    diaries_path: Path
    suggestion_artifact: Path | None
    telemetry_log: Path | None
    config_path: Path
    schema_path: Path

    def _status_heading(self) -> str:
        return self.status.value.upper()

    def to_markdown(self) -> str:
        """Render the drill report as Markdown for documentation packs."""

        lines: list[str] = [
            "# TRM milestone exit drill",
            "",
            f"- Status: {self._status_heading()}",
            f"- Generated: {self.generated_at.isoformat()}",
            f"- Diary source: {self.diaries_path.as_posix()}",
            f"- Suggestions emitted: {self.metrics.suggestion_count}",
        ]

        if self.metrics.suggestion_count:
            lines.append(
                "- Confidence (min/avg/max): "
                f"{self._format_conf(self.metrics.confidence_min)}/"
                f"{self._format_conf(self.metrics.confidence_avg)}/"
                f"{self._format_conf(self.metrics.confidence_max)}"
            )
        if self.suggestion_artifact:
            lines.append(
                f"- Suggestion artifact: {self.suggestion_artifact.as_posix()}"
            )
        if self.telemetry_log:
            lines.append(f"- Telemetry log: {self.telemetry_log.as_posix()}")

        lines.extend(
            [
                "- Config: " + self.config_path.as_posix(),
                "- Schema: " + self.schema_path.as_posix(),
                "",
                "## Drill components",
                "| Component | Status | Summary |",
                "| --- | --- | --- |",
            ]
        )

        for component in self.components:
            lines.append(
                f"| {component.name} | {component.status.value.upper()} | {component.summary} |"
            )

        if any(component.details for component in self.components):
            lines.append("")
            lines.append("## Component details")
            for component in self.components:
                if not component.details:
                    continue
                lines.append(f"### {component.name}")
                for detail in component.details:
                    lines.append(f"- {detail}")
                lines.append("")

        if self.metrics.suggestion_count:
            lines.append("## Suggestion snapshot")
            lines.append("| ID | Type | Confidence | Primary target | Rationale |")
            lines.append("| --- | --- | --- | --- | --- |")
            for suggestion in _iter_suggestion_rows(self.suggestion_artifact):
                lines.append("| " + " | ".join(suggestion) + " |")

        return "\n".join(lines)

    @staticmethod
    def _format_conf(value: float | None) -> str:
        if value is None:
            return "n/a"
        return f"{value:.2f}"


def _iter_suggestion_rows(path: Path | None) -> Iterable[tuple[str, str, str, str, str]]:
    if path is None or not path.exists():
        return []
    rows: list[tuple[str, str, str, str, str]] = []
    with path.open() as handle:
        for line in handle:
            line = line.strip()
            if not line:
                continue
            try:
                payload: Mapping[str, object] = json.loads(line)
            except json.JSONDecodeError:
                continue
            suggestion_id = str(payload.get("suggestion_id", "unknown"))
            suggestion_type = str(payload.get("type", "unknown"))
            confidence = f"{float(payload.get('confidence', 0.0)):.2f}"
            primary_target = _derive_primary_target(payload.get("payload"))
            rationale = str(payload.get("rationale", ""))
            rows.append((suggestion_id, suggestion_type, confidence, primary_target, rationale))
    return rows


def _derive_primary_target(payload: object) -> str:
    if isinstance(payload, Mapping):
        if "strategy_id" in payload:
            return str(payload["strategy_id"])
        if "strategy_candidates" in payload:
            candidates = payload["strategy_candidates"]
            if isinstance(candidates, Sequence) and candidates:
                return str(candidates[0])
    return "n/a"


def _combine_status(current: TRMDrillStatus, incoming: TRMDrillStatus) -> TRMDrillStatus:
    if _STATUS_ORDER[incoming] > _STATUS_ORDER[current]:
        return incoming
    return current


def _load_validator(schema_path: Path) -> Draft7Validator:
    schema_doc = json.loads(schema_path.read_text())
    resolver = RefResolver.from_schema(schema_doc)
    suggestion_schema = schema_doc["definitions"]["RIMSuggestion"]
    return Draft7Validator(suggestion_schema, resolver=resolver)


def _validate_suggestions(
    suggestions: Sequence[Mapping[str, object]],
    validator: Draft7Validator,
) -> list[str]:
    errors: list[str] = []
    for index, suggestion in enumerate(suggestions, 1):
        for err in validator.iter_errors(suggestion):
            errors.append(f"suggestion[{index}] {err.message}")
    return errors


def _build_metrics(suggestions: Sequence[Mapping[str, object]]) -> TRMDrillMetrics:
    counts: MutableMapping[str, int] = {}
    confidences: list[float] = []
    for suggestion in suggestions:
        suggestion_type = str(suggestion.get("type", "unknown"))
        counts[suggestion_type] = counts.get(suggestion_type, 0) + 1
        try:
            confidences.append(float(suggestion.get("confidence", 0.0)))
        except (TypeError, ValueError):
            continue

    if confidences:
        confidence_min = min(confidences)
        confidence_avg = statistics.fmean(confidences)
        confidence_max = max(confidences)
    else:
        confidence_min = confidence_avg = confidence_max = None

    return TRMDrillMetrics(
        suggestion_count=len(suggestions),
        types=dict(sorted(counts.items())),
        confidence_min=confidence_min,
        confidence_avg=confidence_avg,
        confidence_max=confidence_max,
    )


def run_trm_exit_drill(
    diaries_path: Path,
    schema_path: Path,
    *,
    config_path: Path | None = None,
    publish_dir: Path | None = None,
    log_dir: Path | None = None,
) -> TRMDrillReport:
    """Execute the TRM exit drill and return the detailed report."""

    resolved_config_path = config_path or rim_shadow_run.CONFIG_PATH
    config, actual_config_path = rim_shadow_run.load_yaml_config(resolved_config_path)

    if publish_dir is None:
        publish_dir = Path("artifacts/rim_exit_drill")
    publish_dir.mkdir(parents=True, exist_ok=True)
    publish_channel = f"file://{publish_dir.as_posix()}"

    if log_dir is None:
        log_dir = publish_dir / "logs"
    log_dir.mkdir(parents=True, exist_ok=True)

    start_time = time.perf_counter()
    run_timestamp = datetime.now(tz=UTC)
    config_hash = rim_shadow_run.compute_hash(actual_config_path.read_text())

    entries = rim_shadow_run.load_diary_entries(diaries_path) if diaries_path.exists() else []
    diary_details: list[str] = [
        f"Entries loaded: {len(entries)}",
    ]
    diary_status = TRMDrillStatus.PASS if entries else TRMDrillStatus.FAIL
    diary_summary = "Loaded decision diary window" if entries else "No diary entries available"
    diary_component = TRMDrillComponent(
        name="Decision diary intake",
        status=diary_status,
        summary=diary_summary,
        details=tuple(diary_details),
    )

    aggregates = rim_shadow_run.aggregate_by_strategy(entries) if entries else {}
    input_hash = rim_shadow_run.compute_hash(json.dumps(aggregates, sort_keys=True)) if entries else "no-diaries"
    suggestions = (
        rim_shadow_run.build_suggestions(aggregates, config, input_hash, config_hash, run_timestamp)
        if entries
        else []
    )

    generation_status = TRMDrillStatus.PASS if suggestions else TRMDrillStatus.WARN
    generation_summary = (
        f"Generated {len(suggestions)} suggestions" if suggestions else "No suggestions emitted"
    )
    generation_details: list[str] = []
    if aggregates:
        generation_details.append(
            "Aggregated strategies: " + ", ".join(sorted(aggregates.keys()))
        )
    generation_component = TRMDrillComponent(
        name="Suggestion generation",
        status=generation_status,
        summary=generation_summary,
        details=tuple(generation_details),
    )

    suggestion_path: Path | None = None
    if suggestions:
        suggestion_path = rim_shadow_run.write_suggestions(
            [dict(suggestion) for suggestion in suggestions],
            publish_channel,
            run_timestamp,
        )

    runtime = time.perf_counter() - start_time
    rim_shadow_run.log_metrics(log_dir, runtime, len(suggestions), run_timestamp)
    telemetry_log = _latest_log_path(log_dir)
    telemetry_status = TRMDrillStatus.PASS if telemetry_log else TRMDrillStatus.WARN
    telemetry_summary = "Telemetry written" if telemetry_log else "Telemetry log missing"
    telemetry_component = TRMDrillComponent(
        name="Telemetry capture",
        status=telemetry_status,
        summary=telemetry_summary,
        details=tuple([f"Runtime seconds: {runtime:.4f}"]),
    )

    validator = _load_validator(schema_path)
    validation_errors = _validate_suggestions(suggestions, validator)
    validation_status = TRMDrillStatus.PASS if not validation_errors else TRMDrillStatus.FAIL
    validation_summary = (
        "All suggestions conform to rim.v1 schema"
        if not validation_errors
        else "Schema validation failures detected"
    )
    validation_component = TRMDrillComponent(
        name="Schema validation",
        status=validation_status,
        summary=validation_summary,
        details=tuple(validation_errors),
    )

    components = (
        diary_component,
        generation_component,
        validation_component,
        telemetry_component,
    )

    overall_status = TRMDrillStatus.PASS
    for component in components:
        overall_status = _combine_status(overall_status, component.status)

    metrics = _build_metrics(suggestions)

    return TRMDrillReport(
        status=overall_status,
        generated_at=run_timestamp,
        components=components,
        metrics=metrics,
        diaries_path=diaries_path,
        suggestion_artifact=suggestion_path,
        telemetry_log=telemetry_log,
        config_path=actual_config_path,
        schema_path=schema_path,
    )


def _latest_log_path(log_dir: Path) -> Path | None:
    if not log_dir.exists():
        return None
    candidates = sorted(log_dir.glob("rim-*.log"))
    return candidates[-1] if candidates else None


__all__ = [
    "TRMDrillComponent",
    "TRMDrillMetrics",
    "TRMDrillReport",
    "TRMDrillStatus",
    "run_trm_exit_drill",
]

