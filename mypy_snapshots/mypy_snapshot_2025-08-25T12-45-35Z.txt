src/trading/risk_management/__init__.py:18: error: Module
"src.core.risk.stress_testing" has no attribute "StressTester"  [attr-defined]
        from src.core.risk.stress_testing import StressTester
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/risk_management/__init__.py:19: error: Module
"src.core.risk.var_calculator" has no attribute "VarCalculator"  [attr-defined]
        from src.core.risk.var_calculator import VarCalculator as VaRCalcu...
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/trading/risk_management/__init__.py:22: error: Cannot assign to a type 
[misc]
        RiskManager = object
        ^~~~~~~~~~~
src/trading/risk_management/__init__.py:22: error: Incompatible types in
assignment (expression has type "type[object]", variable has type
"type[RiskManager]")  [assignment]
        RiskManager = object
                      ^~~~~~
src/trading/risk_management/__init__.py:24: error: All conditional function
variants must have identical signatures  [misc]
        def KellyCriterion(*args: Any, **kwargs: Any) -> float:
        ^
src/trading/risk_management/__init__.py:24: note: Original:
src/trading/risk_management/__init__.py:24: note:     def kelly_fraction(win_rate: float, avg_win: float, avg_loss: float) -> float
src/trading/risk_management/__init__.py:24: note: Redefinition:
src/trading/risk_management/__init__.py:24: note:     def KellyCriterion(*args: Any, **kwargs: Any) -> float
src/thinking/learning/meta_cognition_engine.py:14: error: Unused "type: ignore"
comment  [unused-ignore]
        LearningSignal = ContextPacket = object  # type: ignore
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/learning/meta_cognition_engine.py:128: error: Argument 1 to
"_calculate_correlation" of "MetaCognitionEngine" has incompatible type
"list[object]"; expected "list[float]"  [arg-type]
    ...       correlation = self._calculate_correlation(predicted_outcomes, a...
                                                        ^~~~~~~~~~~~~~~~~~
src/thinking/learning/meta_cognition_engine.py:128: error: Argument 2 to
"_calculate_correlation" of "MetaCognitionEngine" has incompatible type
"list[object]"; expected "list[float]"  [arg-type]
    ...ion = self._calculate_correlation(predicted_outcomes, actual_outcomes)
                                                             ^~~~~~~~~~~~~~~
src/thinking/learning/meta_cognition_engine.py:131: error: Unsupported left
operand type for - ("object")  [operator]
                mae = sum(abs(p - a) for p, a in zip(predicted_outcomes, a...
                              ^~~~~
src/thinking/learning/meta_cognition_engine.py:134: error: Value of type
variable "SupportsRichComparisonT" of "max" cannot be "object"  [type-var]
                max_possible_error = max(abs(max(actual_outcomes)), abs(mi...
                                             ^~~~~~~~~~~~~~~~~~~~
src/thinking/learning/meta_cognition_engine.py:134: error: Argument 1 to "abs"
has incompatible type "object"; expected "SupportsAbs[Never]"  [arg-type]
                max_possible_error = max(abs(max(actual_outcomes)), abs(mi...
                                             ^~~~~~~~~~~~~~~~~~~~
src/thinking/learning/meta_cognition_engine.py:134: error: Value of type
variable "SupportsRichComparisonT" of "min" cannot be "object"  [type-var]
    ...sible_error = max(abs(max(actual_outcomes)), abs(min(actual_outcomes))...
                                                        ^~~~~~~~~~~~~~~~~~~~
src/thinking/learning/meta_cognition_engine.py:173: error: Returning Any from
function declared to return "float"  [no-any-return]
                return max(0.0, min(1.0, consistency_score))
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/learning/meta_cognition_engine.py:274: error: Returning Any from
function declared to return "float"  [no-any-return]
            return max(-1.0, min(1.0, correlation))
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/learning/meta_cognition_engine.py:298: error: Returning Any from
function declared to return "Decimal"  [no-any-return]
                    return learning_signal.confidence_of_outcome
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/learning/meta_cognition_engine.py:320: error: Returning Any from
function declared to return "Decimal"  [no-any-return]
                return learning_signal.confidence_of_outcome
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/services/symbol_mapper.py:96: error: Argument 1 to "SymbolInfo" has
incompatible type "**dict[str, object]"; expected "int"  [arg-type]
                self._symbols = {name: SymbolInfo(**info) for name, info i...
                                                    ^~~~
src/sensory/services/symbol_mapper.py:96: error: Argument 1 to "SymbolInfo" has
incompatible type "**dict[str, object]"; expected "str"  [arg-type]
                self._symbols = {name: SymbolInfo(**info) for name, info i...
                                                    ^~~~
src/sensory/services/symbol_mapper.py:96: error: Argument 1 to "SymbolInfo" has
incompatible type "**dict[str, object]"; expected "float"  [arg-type]
                self._symbols = {name: SymbolInfo(**info) for name, info i...
                                                    ^~~~
src/sensory/organs/sentiment_organ.py:14: error: Module "src.core.base" has no
attribute "SensoryOrgan"  [attr-defined]
    from src.core.base import MarketData, SensoryOrgan, SensoryReading
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/sentiment_organ.py:14: error: Module "src.core.base" has no
attribute "SensoryReading"  [attr-defined]
    from src.core.base import MarketData, SensoryOrgan, SensoryReading
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/news_organ.py:14: error: Module "src.core.base" has no
attribute "SensoryOrgan"  [attr-defined]
    from src.core.base import MarketData, SensoryOrgan, SensoryReading
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/news_organ.py:14: error: Module "src.core.base" has no
attribute "SensoryReading"  [attr-defined]
    from src.core.base import MarketData, SensoryOrgan, SensoryReading
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/economic_organ.py:14: error: Module "src.core.base" has no
attribute "SensoryOrgan"  [attr-defined]
    from src.core.base import MarketData, SensoryOrgan, SensoryReading
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/economic_organ.py:14: error: Module "src.core.base" has no
attribute "SensoryReading"  [attr-defined]
    from src.core.base import MarketData, SensoryOrgan, SensoryReading
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/base_organ.py:18: error: Module "pydantic" has no
attribute "model_validator"; maybe "root_validator"?  [attr-defined]
    from pydantic import BaseModel, Field, model_validator, validator
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/genome/models/genome.py:237: error: Argument 1 to "DecisionGenome" has
incompatible type
"**dict[str, list[str] | dict[str, float] | float | str | None]"; expected "str"
 [arg-type]
            return DecisionGenome(**data)
                                    ^~~~
src/genome/models/genome.py:237: error: Argument 1 to "DecisionGenome" has
incompatible type
"**dict[str, list[str] | dict[str, float] | float | str | None]"; expected
"dict[str, float]"  [arg-type]
            return DecisionGenome(**data)
                                    ^~~~
src/genome/models/genome.py:237: error: Argument 1 to "DecisionGenome" has
incompatible type
"**dict[str, list[str] | dict[str, float] | float | str | None]"; expected
"float | None"  [arg-type]
            return DecisionGenome(**data)
                                    ^~~~
src/genome/models/genome.py:237: error: Argument 1 to "DecisionGenome" has
incompatible type
"**dict[str, list[str] | dict[str, float] | float | str | None]"; expected "int"
 [arg-type]
            return DecisionGenome(**data)
                                    ^~~~
src/genome/models/genome.py:237: error: Argument 1 to "DecisionGenome" has
incompatible type
"**dict[str, list[str] | dict[str, float] | float | str | None]"; expected
"str | None"  [arg-type]
            return DecisionGenome(**data)
                                    ^~~~
src/genome/models/genome.py:237: error: Argument 1 to "DecisionGenome" has
incompatible type
"**dict[str, list[str] | dict[str, float] | float | str | None]"; expected
"list[str]"  [arg-type]
            return DecisionGenome(**data)
                                    ^~~~
src/genome/models/genome.py:237: error: Argument 1 to "DecisionGenome" has
incompatible type
"**dict[str, list[str] | dict[str, float] | float | str | None]"; expected
"float"  [arg-type]
            return DecisionGenome(**data)
                                    ^~~~
src/evolution/mutation/gaussian_mutation.py:13: error: Module
"src.core.interfaces" has no attribute "IMutationStrategy"  [attr-defined]
    from src.core.interfaces import DecisionGenome, IMutationStrategy
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:52: error: "DecisionGenome" has no
attribute "genome_id"  [attr-defined]
            mutated.genome_id = f"{genome.genome_id}_mutated_{random.randi...
            ^~~~~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:53: error: "DecisionGenome" has no
attribute "mutation_count"  [attr-defined]
            mutated.mutation_count = genome.mutation_count + 1
            ^~~~~~~~~~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:57: error: "DecisionGenome" has no
attribute "strategy"  [attr-defined]
                mutated.strategy.entry_threshold = self._mutate_parameter(
                ^~~~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:58: error: "DecisionGenome" has no
attribute "strategy"  [attr-defined]
                    mutated.strategy.entry_threshold, 0.0, 1.0
                    ^~~~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:61: error: "DecisionGenome" has no
attribute "strategy"  [attr-defined]
                mutated.strategy.exit_threshold = self._mutate_parameter(
                ^~~~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:62: error: "DecisionGenome" has no
attribute "strategy"  [attr-defined]
                    mutated.strategy.exit_threshold, 0.0, 1.0
                    ^~~~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:65: error: "DecisionGenome" has no
attribute "strategy"  [attr-defined]
                mutated.strategy.momentum_weight = self._mutate_parameter(
                ^~~~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:66: error: "DecisionGenome" has no
attribute "strategy"  [attr-defined]
                    mutated.strategy.momentum_weight, 0.0, 1.0
                    ^~~~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:69: error: "DecisionGenome" has no
attribute "strategy"  [attr-defined]
                mutated.strategy.trend_weight = self._mutate_parameter(
                ^~~~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:70: error: "DecisionGenome" has no
attribute "strategy"  [attr-defined]
                    mutated.strategy.trend_weight, 0.0, 1.0
                    ^~~~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:73: error: "DecisionGenome" has no
attribute "strategy"  [attr-defined]
                mutated.strategy.volume_weight = self._mutate_parameter(
                ^~~~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:74: error: "DecisionGenome" has no
attribute "strategy"  [attr-defined]
                    mutated.strategy.volume_weight, 0.0, 1.0
                    ^~~~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:77: error: "DecisionGenome" has no
attribute "strategy"  [attr-defined]
                mutated.strategy.sentiment_weight = self._mutate_parameter...
                ^~~~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:78: error: "DecisionGenome" has no
attribute "strategy"  [attr-defined]
                    mutated.strategy.sentiment_weight, 0.0, 1.0
                    ^~~~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:81: error: "DecisionGenome" has no
attribute "strategy"  [attr-defined]
                mutated.strategy.lookback_period = int(
                ^~~~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:82: error: "DecisionGenome" has no
attribute "strategy"  [attr-defined]
                    self._mutate_parameter(mutated.strategy.lookback_perio...
                                           ^~~~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:87: error: "DecisionGenome" has no
attribute "risk"  [attr-defined]
                mutated.risk.risk_tolerance = self._mutate_parameter(
                ^~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:88: error: "DecisionGenome" has no
attribute "risk"  [attr-defined]
                    mutated.risk.risk_tolerance, 0.0, 1.0
                    ^~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:91: error: "DecisionGenome" has no
attribute "risk"  [attr-defined]
                mutated.risk.position_size_multiplier = self._mutate_param...
                ^~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:92: error: "DecisionGenome" has no
attribute "risk"  [attr-defined]
                    mutated.risk.position_size_multiplier, 0.1, 5.0
                    ^~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:95: error: "DecisionGenome" has no
attribute "risk"  [attr-defined]
                mutated.risk.stop_loss_threshold = self._mutate_parameter(
                ^~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:96: error: "DecisionGenome" has no
attribute "risk"  [attr-defined]
                    mutated.risk.stop_loss_threshold, 0.001, 0.1
                    ^~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:99: error: "DecisionGenome" has no
attribute "risk"  [attr-defined]
                mutated.risk.take_profit_threshold = self._mutate_paramete...
                ^~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:100: error: "DecisionGenome" has no
attribute "risk"  [attr-defined]
                    mutated.risk.take_profit_threshold, 0.001, 0.2
                    ^~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:103: error: "DecisionGenome" has no
attribute "risk"  [attr-defined]
                mutated.risk.max_drawdown_limit = self._mutate_parameter(
                ^~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:104: error: "DecisionGenome" has no
attribute "risk"  [attr-defined]
                    mutated.risk.max_drawdown_limit, 0.01, 0.5
                    ^~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:107: error: "DecisionGenome" has no
attribute "risk"  [attr-defined]
                mutated.risk.volatility_threshold = self._mutate_parameter...
                ^~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:108: error: "DecisionGenome" has no
attribute "risk"  [attr-defined]
                    mutated.risk.volatility_threshold, 0.01, 1.0
                    ^~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:111: error: "DecisionGenome" has no
attribute "risk"  [attr-defined]
                mutated.risk.correlation_threshold = self._mutate_paramete...
                ^~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:112: error: "DecisionGenome" has no
attribute "risk"  [attr-defined]
                    mutated.risk.correlation_threshold, 0.0, 1.0
                    ^~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:117: error: "DecisionGenome" has no
attribute "timing"  [attr-defined]
                mutated.timing.holding_period_min = max(
                ^~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:118: error: "DecisionGenome" has no
attribute "timing"  [attr-defined]
                    0, int(self._mutate_parameter(mutated.timing.holding_p...
                                                  ^~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:121: error: "DecisionGenome" has no
attribute "timing"  [attr-defined]
                mutated.timing.holding_period_max = max(
                ^~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:122: error: "DecisionGenome" has no
attribute "timing"  [attr-defined]
                    mutated.timing.holding_period_min + 1,
                    ^~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:123: error: "DecisionGenome" has no
attribute "timing"  [attr-defined]
                    int(self._mutate_parameter(mutated.timing.holding_peri...
                                               ^~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:126: error: "DecisionGenome" has no
attribute "timing"  [attr-defined]
                mutated.timing.reentry_delay = max(
                ^~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:127: error: "DecisionGenome" has no
attribute "timing"  [attr-defined]
                    0, int(self._mutate_parameter(mutated.timing.reentry_d...
                                                  ^~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:143: error: "DecisionGenome" has no
attribute "sensory"  [attr-defined]
                        mutated.sensory,
                        ^~~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:145: error: "DecisionGenome" has no
attribute "sensory"  [attr-defined]
    ...                  self._mutate_parameter(getattr(mutated.sensory, weig...
                                                        ^~~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:159: error: "DecisionGenome" has no
attribute "thinking"  [attr-defined]
                        mutated.thinking,
                        ^~~~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:161: error: "DecisionGenome" has no
attribute "thinking"  [attr-defined]
    ...                  self._mutate_parameter(getattr(mutated.thinking, wei...
                                                        ^~~~~~~~~~~~~~~~
src/evolution/mutation/gaussian_mutation.py:166: error: "DecisionGenome" has no
attribute "_normalize_weights"  [attr-defined]
            mutated._normalize_weights()
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
src/evolution/ambusher/ambusher_orchestrator.py:20: error: Function is missing
a type annotation  [no-untyped-def]
            def __init__(self, *_args, **_kwargs):
            ^
src/evolution/ambusher/ambusher_orchestrator.py:33: error: Too many arguments
for "AmbusherFitnessFunction"  [call-arg]
            self.fitness_function = AmbusherFitnessFunction(config.get('fi...
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/evolution/ambusher/ambusher_orchestrator.py:54: error: Function is missing
a return type annotation  [no-untyped-def]
        async def start(self):
        ^
src/evolution/ambusher/ambusher_orchestrator.py:54: note: Use "-> None" if function does not return a value
src/evolution/ambusher/ambusher_orchestrator.py:61: error: "EvolutionEngine"
has no attribute "load_genome"  [attr-defined]
                self.current_genome = self.genetic_engine.load_genome(str(...
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/evolution/ambusher/ambusher_orchestrator.py:66: error: Function is missing
a return type annotation  [no-untyped-def]
        async def stop(self):
        ^
src/evolution/ambusher/ambusher_orchestrator.py:66: note: Use "-> None" if function does not return a value
src/evolution/ambusher/ambusher_orchestrator.py:80: error: "evolve" of
"EvolutionEngine" does not return a value (it only ever returns None) 
[func-returns-value]
            _ = self.genetic_engine.evolve()
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/evolution/ambusher/ambusher_orchestrator.py:119: error: Returning Any from
function declared to return "dict[str, Any] | None"  [no-any-return]
                    return self.current_genome.to_dict()
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/evolution/ambusher/ambusher_orchestrator.py:131: error: Function is missing
a return type annotation  [no-untyped-def]
        async def reset(self):
        ^
src/evolution/ambusher/ambusher_orchestrator.py:131: note: Use "-> None" if function does not return a value
src/evolution/ambusher/ambusher_orchestrator.py:155: error: Function is missing
a return type annotation  [no-untyped-def]
        def update_trade_metrics(self, trade_data: Dict[str, Any]):
        ^
src/ui/ui_manager.py:16: error: Module "src.governance.strategy_registry" has
no attribute "StrategyStatus"  [attr-defined]
        from src.governance.strategy_registry import StrategyRegistry, Str...
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/ui/ui_manager.py:19: error: Name "EventBus" already defined (possibly by an
import)  [no-redef]
        class EventBus:
        ^
src/ui/ui_manager.py:32: error: Name "StrategyStatus" already defined (possibly
by an import)  [no-redef]
        class StrategyStatus:
        ^
src/ui/ui_manager.py:38: error: Name "StrategyRegistry" already defined
(possibly by an import)  [no-redef]
        class StrategyRegistry:
        ^
src/thinking/patterns/cvd_divergence_detector.py:14: error: Cannot assign to a
type  [misc]
        ContextPacket = object
        ^~~~~~~~~~~~~
src/thinking/patterns/cvd_divergence_detector.py:14: error: Incompatible types
in assignment (expression has type "type[object]", variable has type
"type[ContextPacket]")  [assignment]
        ContextPacket = object
                        ^~~~~~
src/sensory/enhanced/when_dimension.py:43: error: Argument "regime" to
"DimensionalReading" has incompatible type
"src.sensory.organs.dimensions.base_organ.MarketRegime"; expected
"src.core.base.MarketRegime"  [arg-type]
                regime=MarketRegime.UNKNOWN,
                       ^~~~~~~~~~~~~~~~~~~~
src/sensory/enhanced/what_dimension.py:43: error: Argument "regime" to
"DimensionalReading" has incompatible type
"src.sensory.organs.dimensions.base_organ.MarketRegime"; expected
"src.core.base.MarketRegime"  [arg-type]
                regime=MarketRegime.UNKNOWN,
                       ^~~~~~~~~~~~~~~~~~~~
src/evolution/engine/__init__.py:8: error: Unused "type: ignore" comment 
[unused-ignore]
    from src.core.evolution.engine import EvolutionConfig, EvolutionEngine...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/evolution/engine/__init__.py:11: error: Unused "type: ignore" comment 
[unused-ignore]
    from src.core.evolution.population import Population  # type: ignore
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/evolution/__init__.py:17: error: Unused "type: ignore" comment 
[unused-ignore]
    from src.core.evolution.engine import EvolutionConfig, EvolutionEngine...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/evolution/__init__.py:18: error: Unused "type: ignore" comment 
[unused-ignore]
    from src.core.evolution.fitness import FitnessEvaluator  # type: ignor...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/evolution/__init__.py:20: error: Unused "type: ignore" comment 
[unused-ignore]
    from src.core.evolution.population import Population  # type: ignore
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/domain/__init__.py:12: error: Module "src.core.risk.manager" has no
attribute "RiskConfig"  [attr-defined]
    from src.core.risk.manager import RiskConfig as RiskConfig
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/data_foundation/config/why_config.py:10: error: Incompatible types in
assignment (expression has type "None", variable has type Module)  [assignment]
        yaml = None
               ^~~~
src/data_foundation/config/sizing_config.py:10: error: Incompatible types in
assignment (expression has type "None", variable has type Module)  [assignment]
        yaml = None
               ^~~~
src/data_foundation/config/sizing_config.py:18: error: Missing type parameters
for generic type "dict"  [type-arg]
        regime_multipliers: dict = None # e.g., {"calm":1.0,"normal":0.8,"...
                            ^
src/data_foundation/config/sizing_config.py:18: error: Incompatible types in
assignment (expression has type "None", variable has type "dict[Any, Any]") 
[assignment]
        regime_multipliers: dict = None # e.g., {"calm":1.0,"normal":0.8,"...
                                   ^~~~
src/data_foundation/config/risk_portfolio_config.py:10: error: Incompatible
types in assignment (expression has type "None", variable has type Module) 
[assignment]
        yaml = None
               ^~~~
src/data_foundation/config/execution_config.py:10: error: Incompatible types in
assignment (expression has type "None", variable has type Module)  [assignment]
        yaml = None
               ^~~~
src/core/configuration.py:124: error: Unsupported target for indexed assignment
("Configuration")  [index]
            config[keys[-1]] = value
            ^~~~~~~~~~~~~~~~
src/genome/models/genome_adapter.py:30: error: Cannot assign to a type  [misc]
        _DecisionGenome = None  # type: ignore[assignment]
        ^~~~~~~~~~~~~~~
src/genome/models/genome_adapter.py:30: note: Error code "misc" not covered by "type: ignore" comment
src/genome/models/genome_adapter.py:31: error: Incompatible types in assignment
(expression has type "None", variable has type
"Callable[[DecisionGenome, str, dict[str, float]], DecisionGenome]") 
[assignment]
        _mutate = None
                  ^~~~
src/genome/models/genome_adapter.py:32: error: Incompatible types in assignment
(expression has type "None", variable has type
"Callable[[str, dict[str, float], int, str | None], DecisionGenome]") 
[assignment]
        _new_genome = None
                      ^~~~
src/genome/models/genome_adapter.py:40: error: Incompatible types in assignment
(expression has type "None", variable has type
"Callable[[Any], DecisionGenome]")  [assignment]
        _from_legacy = None
                       ^~~~
src/genome/models/genome_adapter.py:41: error: Incompatible types in assignment
(expression has type "None", variable has type
"Callable[[DecisionGenome], dict[str, Any]]")  [assignment]
        _to_legacy_view = None
                          ^~~~
src/trading/execution/fix_executor.py:16: error: Module "src.core.interfaces"
has no attribute "IExecutionEngine"  [attr-defined]
        from src.core.interfaces import IExecutionEngine
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/execution/fix_executor.py:166: error: Non-overlapping container
check (element type: "OrderType", container item type: "str") 
[comparison-overlap]
            if order.order_type not in ['MARKET', 'LIMIT', 'STOP']:
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/execution/fix_executor.py:200: error: Unsupported operand types for
* ("None" and "float")  [operator]
                     order.average_price * order.filled_quantity) / positi...
                     ^
src/trading/execution/fix_executor.py:200: note: Left operand is of type "float | None"
src/trading/execution/fix_executor.py:204: error: Unsupported operand types for
- ("None" and "float")  [operator]
                position.realized_pnl += (order.average_price - position.a...
                                          ^
src/trading/execution/fix_executor.py:204: note: Left operand is of type "float | None"
src/risk/risk_manager_impl.py:260: error: Argument 2 of
"evaluate_portfolio_risk" is incompatible with supertype
"src.core.interfaces.RiskManager"; supertype defines the argument type as
"Mapping[str, object] | None"  [override]
            context: JSONObject | None = None,
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
src/risk/risk_manager_impl.py:260: note: This violates the Liskov substitution principle
src/risk/risk_manager_impl.py:260: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
src/risk/risk_manager_impl.py:272: error: Argument 2 of "propose_rebalance" is
incompatible with supertype "src.core.interfaces.RiskManager"; supertype defines
the argument type as "Mapping[str, object] | None"  [override]
            constraints: JSONObject | None = None,
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/risk/risk_manager_impl.py:272: note: This violates the Liskov substitution principle
src/risk/risk_manager_impl.py:272: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
src/risk/risk_manager_impl.py:277: error: Argument 1 of "update_limits" is
incompatible with supertype "src.core.interfaces.RiskManager"; supertype defines
the argument type as "Mapping[str, object]"  [override]
        def update_limits(self, limits: Mapping[str, float | Decimal]) -> ...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/risk/risk_manager_impl.py:277: note: This violates the Liskov substitution principle
src/risk/risk_manager_impl.py:277: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
src/orchestration/enhanced_intelligence_engine.py:147: error: Returning Any
from function declared to return "float"  [no-any-return]
            return max(-1.0, min(1.0, corr))
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/orchestration/enhanced_intelligence_engine.py:174: error: "object" not
callable  [operator]
            self._why = EnhancedFundamentalIntelligenceEngine()
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/orchestration/enhanced_intelligence_engine.py:175: error: "object" not
callable  [operator]
            self._how = InstitutionalIntelligenceEngine()
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/orchestration/enhanced_intelligence_engine.py:176: error: "object" not
callable  [operator]
            self._what = TechnicalRealityEngine()
                         ^~~~~~~~~~~~~~~~~~~~~~~~
src/orchestration/enhanced_intelligence_engine.py:177: error: "object" not
callable  [operator]
            self._when = ChronalIntelligenceEngine()
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
src/orchestration/enhanced_intelligence_engine.py:178: error: "object" not
callable  [operator]
            self._anomaly = AnomalyIntelligenceEngine()
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~
src/operational/health_monitor.py:28: error: Need type annotation for
"health_history" (hint: "health_history: list[<type>] = ...")  [var-annotated]
            self.health_history = []
            ^~~~~~~~~~~~~~~~~~~
src/core/_event_bus_impl.py:295: error: Argument 2 to "subscribe" of
"AsyncEventBus" has incompatible type "Callable[[Event], object]"; expected
"Callable[[Event], Awaitable[None]] | Callable[[Event], None]"  [arg-type]
            return self._bus.subscribe(topic, adapter_fn)
                                              ^~~~~~~~~~
src/core/_event_bus_impl.py:325: error: Argument 2 to "subscribe_topic" of
"TopicBus" has incompatible type "Callable[[str, object], object]"; expected
"Callable[[str, Any], Awaitable[None] | None]"  [arg-type]
            return self.subscribe_topic(topic, adapter)
                                               ^~~~~~~
src/core/_event_bus_impl.py:407: error: Argument "handler" to
"SubscriptionHandle" has incompatible type "Callable[[Event], object]"; expected
"Callable[[Event], Awaitable[None]] | Callable[[Event], None]"  [arg-type]
    ...SubscriptionHandle(id=sub_id, event_type=event_type, handler=callback)
                                                                    ^~~~~~~~
src/trading/execution/liquidity_prober.py:47: error: Argument 1 to "float" has
incompatible type "object"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
            self.timeout_seconds: float = float(self.config.get("timeout_s...
                                                ^~~~~~~~~~~~~~~~~~~~~~~~~~...
src/trading/execution/liquidity_prober.py:48: error: No overload variant of
"int" matches argument type "object"  [call-overload]
            self.max_concurrent_probes: int = int(self.config.get("max_con...
                                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/trading/execution/liquidity_prober.py:48: note: Possible overload variants:
src/trading/execution/liquidity_prober.py:48: note:     def __new__(cls, str | Buffer | SupportsInt | SupportsIndex | SupportsTrunc = ..., /) -> int
src/trading/execution/liquidity_prober.py:48: note:     def __new__(cls, str | bytes | bytearray, /, base: SupportsIndex) -> int
src/trading/execution/liquidity_prober.py:200: error: Argument 1 to "float" has
incompatible type "object"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
                    return float(status.get("filled_qty") or 0.0)
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/strategies/order_book_analyzer.py:85: error: Missing type
parameters for generic type "deque"  [type-arg]
            self.order_book_history: Dict[str, deque] = defaultdict(
                                               ^
src/trading/strategies/order_book_analyzer.py:90: error: Missing type
parameters for generic type "deque"  [type-arg]
            self.microstructure_history: Dict[str, deque] = defaultdict(
                                                   ^
src/trading/strategies/order_book_analyzer.py:246: error: Returning Any from
function declared to return "float"  [no-any-return]
            return avg_imbalance
            ^~~~~~~~~~~~~~~~~~~~
src/trading/strategies/order_book_analyzer.py:266: error: Returning Any from
function declared to return "float"  [no-any-return]
            return sum(bid_liquidity_trend) / len(bid_liquidity_trend)
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/strategies/order_book_analyzer.py:286: error: Returning Any from
function declared to return "float"  [no-any-return]
            return sum(ask_liquidity_trend) / len(ask_liquidity_trend)
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/strategies/order_book_analyzer.py:330: error: Returning Any from
function declared to return "float"  [no-any-return]
            return np.std(price_changes)
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/strategies/order_book_analyzer.py:350: error: Returning Any from
function declared to return "float"  [no-any-return]
            return np.std(liquidity_changes)
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/strategies/order_book_analyzer.py:449: error: Returning Any from
function declared to return "float"  [no-any-return]
            return latest.mid_price
            ^~~~~~~~~~~~~~~~~~~~~~~
src/trading/strategies/order_book_analyzer.py:494: error: Incompatible return
value type (got "dict[str, str]", expected "dict[str, object]")  [return-value]
            return signals
                   ^~~~~~~
src/trading/strategies/order_book_analyzer.py:494: note: "dict" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance
src/trading/strategies/order_book_analyzer.py:494: note: Consider using "Mapping" instead, which is covariant in the value type
src/trading/strategies/order_book_analyzer.py:494: note: Perhaps you need a type annotation for "signals"? Suggestion: "dict[str, object]"
src/trading/strategies/order_book_analyzer.py:546: error: Returning Any from
function declared to return "OrderBookSnapshot | None"  [no-any-return]
            return self.order_book_history[symbol][-1]
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/strategies/order_book_analyzer.py:584: error: "Sequence[str]" has
no attribute "append"  [attr-defined]
                data['snapshots'].append(snapshot_data)
                ^~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/prediction/predictive_market_modeler.py:22: error: Unused
"type: ignore" comment  [unused-ignore]
        ContextPacket = PredictionResult = object  # type: ignore
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/prediction/predictive_market_modeler.py:46: error: Function is
missing a return type annotation  [no-untyped-def]
        def __init__(self):
        ^
src/thinking/prediction/predictive_market_modeler.py:46: note: Use "-> None" if function does not return a value
src/thinking/prediction/predictive_market_modeler.py:90: error: Unsupported
operand types for * ("object" and "float")  [operator]
                    volatility = current_state.get('volatility', 0.02) * t...
                                 ^
src/thinking/prediction/predictive_market_modeler.py:95: error: Argument 1 to
"_generate_price_path" of "MarketScenarioGenerator" has incompatible type
"object"; expected "float"  [arg-type]
                        current_state.get('price', 100),
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/prediction/predictive_market_modeler.py:161: error: Unsupported
operand types for < ("float" and "object")  [operator]
                if volatility > 0.05:
                   ^
src/thinking/prediction/predictive_market_modeler.py:174: error: Function is
missing a return type annotation  [no-untyped-def]
        def __init__(self):
        ^
src/thinking/prediction/predictive_market_modeler.py:174: note: Use "-> None" if function does not return a value
src/thinking/prediction/predictive_market_modeler.py:238: error: Function is
missing a return type annotation  [no-untyped-def]
        def __init__(self):
        ^
src/thinking/prediction/predictive_market_modeler.py:238: note: Use "-> None" if function does not return a value
src/thinking/prediction/predictive_market_modeler.py:319: error: Function is
missing a return type annotation  [no-untyped-def]
        def __init__(self):
        ^
src/thinking/prediction/predictive_market_modeler.py:319: note: Use "-> None" if function does not return a value
src/thinking/prediction/predictive_market_modeler.py:368: error: Unsupported
operand types for < ("float" and "object")  [operator]
                if historical_accuracy > 0.8:
                   ^
src/thinking/prediction/predictive_market_modeler.py:370: error: Unsupported
operand types for > ("float" and "object")  [operator]
                elif historical_accuracy < 0.6:
                     ^
src/thinking/prediction/predictive_market_modeler.py:469: error: Returning Any
from function declared to return "dict[str, object]"  [no-any-return]
                        return literal_eval(data)
                        ^~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/prediction/predictive_market_modeler.py:499: error: Argument 1 to
"append" of "list" has incompatible type "dict[str, float]"; expected
"dict[str, object]"  [arg-type]
                    payload_list.append(normalize_prediction(p))
                                        ^~~~~~~~~~~~~~~~~~~~~~~
src/thinking/prediction/predictive_market_modeler.py:499: note: "dict" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance
src/thinking/prediction/predictive_market_modeler.py:499: note: Consider using "Mapping" instead, which is covariant in the value type
src/thinking/patterns/trend_detector.py:19: error: Module "src.core.exceptions"
has no attribute "ThinkingException"; maybe "TradingException"?  [attr-defined]
    from src.core.exceptions import ThinkingException
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/patterns/trend_detector.py:67: error: Extra keys ("timestamp",
"analysis_type", "result", "confidence", "metadata") for TypedDict
"AnalysisResult"  [typeddict-unknown-key]
                return AnalysisResult(
                       ^
src/thinking/patterns/trend_detector.py:90: error: Argument 1 of "learn" is
incompatible with supertype "src.core.interfaces.ThinkingPattern"; supertype
defines the argument type as "Mapping[str, object]"  [override]
        def learn(self, feedback: dict[str, object]) -> bool:
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/patterns/trend_detector.py:90: note: This violates the Liskov substitution principle
src/thinking/patterns/trend_detector.py:90: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
src/thinking/patterns/trend_detector.py:97: error: Unsupported operand types
for > ("float" and "object")  [operator]
                    if accuracy < 0.5:
                       ^
src/thinking/patterns/trend_detector.py:98: error: Unsupported operand types
for * ("object" and "float")  [operator]
                        self.min_confidence *= 0.9  # Lower threshold
                        ^
src/thinking/patterns/trend_detector.py:99: error: Unsupported operand types
for < ("float" and "object")  [operator]
                    elif accuracy > 0.8:
                         ^
src/thinking/patterns/trend_detector.py:100: error: Unsupported operand types
for * ("object" and "float")  [operator]
                        self.min_confidence *= 1.1  # Raise threshold
                        ^
src/thinking/patterns/trend_detector.py:105: error: Unsupported operand types
for < ("float" and "object")  [operator]
                    if strength_error > 0.3:
                       ^
src/thinking/patterns/trend_detector.py:106: error: Unsupported operand types
for * ("object" and "float")  [operator]
                        self.min_strength *= 0.9
                        ^
src/thinking/patterns/trend_detector.py:107: error: Unsupported operand types
for > ("float" and "object")  [operator]
                    elif strength_error < 0.1:
                         ^
src/thinking/patterns/trend_detector.py:108: error: Unsupported operand types
for * ("object" and "float")  [operator]
                        self.min_strength *= 1.1
                        ^
src/thinking/patterns/trend_detector.py:117: error: Function is missing a
return type annotation  [no-untyped-def]
        def _update_signal_history(self, signals: List[SensorySignal]):
        ^
src/thinking/patterns/trend_detector.py:122: error: Unsupported operand types
for * ("object" and "int")  [operator]
            if len(self._signal_history) > self.lookback_periods * 10:
                                           ^
src/thinking/patterns/trend_detector.py:123: error: Unsupported operand type
for unary - ("object")  [operator]
    ...     self._signal_history = self._signal_history[-self.lookback_period...
                                                        ^~~~~~~~~~~~~~~~~~~~~~
src/thinking/patterns/trend_detector.py:130: error: "SensorySignal" has no
attribute "signal_type"  [attr-defined]
                if signal.signal_type in ['price_composite', 'volume_compo...
                   ^~~~~~~~~~~~~~~~~~
src/thinking/patterns/trend_detector.py:137: error: "SensorySignal" has no
attribute "signal_type"  [attr-defined]
            price_signals = [s for s in signals if s.signal_type == 'price...
                                                   ^~~~~~~~~~~~~
src/thinking/patterns/trend_detector.py:150: error: "SensorySignal" has no
attribute "value"  [attr-defined]
            avg_value = np.mean([s.value for s in recent_signals])
                                 ^~~~~~~
src/thinking/patterns/trend_detector.py:160: error: No overload variant of
"min" matches argument types "floating[Any]", "float"  [call-overload]
            strength = min(abs(avg_value), 1.0)
                       ^~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/patterns/trend_detector.py:160: note: Possible overload variants:
src/thinking/patterns/trend_detector.py:160: note:     def [SupportsRichComparisonT: SupportsDunderLT[Any] | SupportsDunderGT[Any]] min(SupportsRichComparisonT, SupportsRichComparisonT, /, *_args: SupportsRichComparisonT, key: None = ...) -> SupportsRichComparisonT
src/thinking/patterns/trend_detector.py:160: note:     def [_T] min(_T, _T, /, *_args: _T, key: Callable[[_T], SupportsDunderLT[Any] | SupportsDunderGT[Any]]) -> _T
src/thinking/patterns/trend_detector.py:160: note:     def [SupportsRichComparisonT: SupportsDunderLT[Any] | SupportsDunderGT[Any]] min(Iterable[SupportsRichComparisonT], /, *, key: None = ...) -> SupportsRichComparisonT
src/thinking/patterns/trend_detector.py:160: note:     def [_T] min(Iterable[_T], /, *, key: Callable[[_T], SupportsDunderLT[Any] | SupportsDunderGT[Any]]) -> _T
src/thinking/patterns/trend_detector.py:160: note:     def [SupportsRichComparisonT: SupportsDunderLT[Any] | SupportsDunderGT[Any], _T] min(Iterable[SupportsRichComparisonT], /, *, key: None = ..., default: _T) -> SupportsRichComparisonT | _T
src/thinking/patterns/trend_detector.py:160: note:     def [_T1, _T2] min(Iterable[_T1], /, *, key: Callable[[_T1], SupportsDunderLT[Any] | SupportsDunderGT[Any]], default: _T2) -> _T1 | _T2
src/thinking/patterns/trend_detector.py:163: error: "SensorySignal" has no
attribute "confidence"  [attr-defined]
            confidences = [s.confidence for s in recent_signals]
                           ^~~~~~~~~~~~
src/thinking/patterns/trend_detector.py:182: error: "SensorySignal" has no
attribute "signal_type"  [attr-defined]
    ...       momentum_signals = [s for s in signals if s.signal_type == 'mom...
                                                        ^~~~~~~~~~~~~
src/thinking/patterns/trend_detector.py:195: error: "SensorySignal" has no
attribute "value"  [attr-defined]
            avg_momentum = np.mean([s.value for s in recent_signals])
                                    ^~~~~~~
src/thinking/patterns/trend_detector.py:205: error: No overload variant of
"min" matches argument types "floating[Any]", "float"  [call-overload]
            strength = min(abs(avg_momentum), 1.0)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/patterns/trend_detector.py:205: note: Possible overload variants:
src/thinking/patterns/trend_detector.py:205: note:     def [SupportsRichComparisonT: SupportsDunderLT[Any] | SupportsDunderGT[Any]] min(SupportsRichComparisonT, SupportsRichComparisonT, /, *_args: SupportsRichComparisonT, key: None = ...) -> SupportsRichComparisonT
src/thinking/patterns/trend_detector.py:205: note:     def [_T] min(_T, _T, /, *_args: _T, key: Callable[[_T], SupportsDunderLT[Any] | SupportsDunderGT[Any]]) -> _T
src/thinking/patterns/trend_detector.py:205: note:     def [SupportsRichComparisonT: SupportsDunderLT[Any] | SupportsDunderGT[Any]] min(Iterable[SupportsRichComparisonT], /, *, key: None = ...) -> SupportsRichComparisonT
src/thinking/patterns/trend_detector.py:205: note:     def [_T] min(Iterable[_T], /, *, key: Callable[[_T], SupportsDunderLT[Any] | SupportsDunderGT[Any]]) -> _T
src/thinking/patterns/trend_detector.py:205: note:     def [SupportsRichComparisonT: SupportsDunderLT[Any] | SupportsDunderGT[Any], _T] min(Iterable[SupportsRichComparisonT], /, *, key: None = ..., default: _T) -> SupportsRichComparisonT | _T
src/thinking/patterns/trend_detector.py:205: note:     def [_T1, _T2] min(Iterable[_T1], /, *, key: Callable[[_T1], SupportsDunderLT[Any] | SupportsDunderGT[Any]], default: _T2) -> _T1 | _T2
src/thinking/patterns/trend_detector.py:208: error: "SensorySignal" has no
attribute "confidence"  [attr-defined]
            confidences = [s.confidence for s in recent_signals]
                           ^~~~~~~~~~~~
src/thinking/patterns/trend_detector.py:224: error: "SensorySignal" has no
attribute "signal_type"  [attr-defined]
            volume_signals = [s for s in signals if s.signal_type == 'volu...
                                                    ^~~~~~~~~~~~~
src/thinking/patterns/trend_detector.py:237: error: "SensorySignal" has no
attribute "value"  [attr-defined]
            avg_volume = np.mean([s.value for s in recent_signals])
                                  ^~~~~~~
src/thinking/patterns/trend_detector.py:247: error: No overload variant of
"min" matches argument types "floating[Any]", "float"  [call-overload]
            strength = min(abs(avg_volume), 1.0)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/patterns/trend_detector.py:247: note: Possible overload variants:
src/thinking/patterns/trend_detector.py:247: note:     def [SupportsRichComparisonT: SupportsDunderLT[Any] | SupportsDunderGT[Any]] min(SupportsRichComparisonT, SupportsRichComparisonT, /, *_args: SupportsRichComparisonT, key: None = ...) -> SupportsRichComparisonT
src/thinking/patterns/trend_detector.py:247: note:     def [_T] min(_T, _T, /, *_args: _T, key: Callable[[_T], SupportsDunderLT[Any] | SupportsDunderGT[Any]]) -> _T
src/thinking/patterns/trend_detector.py:247: note:     def [SupportsRichComparisonT: SupportsDunderLT[Any] | SupportsDunderGT[Any]] min(Iterable[SupportsRichComparisonT], /, *, key: None = ...) -> SupportsRichComparisonT
src/thinking/patterns/trend_detector.py:247: note:     def [_T] min(Iterable[_T], /, *, key: Callable[[_T], SupportsDunderLT[Any] | SupportsDunderGT[Any]]) -> _T
src/thinking/patterns/trend_detector.py:247: note:     def [SupportsRichComparisonT: SupportsDunderLT[Any] | SupportsDunderGT[Any], _T] min(Iterable[SupportsRichComparisonT], /, *, key: None = ..., default: _T) -> SupportsRichComparisonT | _T
src/thinking/patterns/trend_detector.py:247: note:     def [_T1, _T2] min(Iterable[_T1], /, *, key: Callable[[_T1], SupportsDunderLT[Any] | SupportsDunderGT[Any]], default: _T2) -> _T1 | _T2
src/thinking/patterns/trend_detector.py:250: error: "SensorySignal" has no
attribute "confidence"  [attr-defined]
            confidences = [s.confidence for s in recent_signals]
                           ^~~~~~~~~~~~
src/thinking/patterns/trend_detector.py:306: error: Argument "key" to "max" has
incompatible type overloaded function; expected
"Callable[[str], SupportsDunderLT[Any] | SupportsDunderGT[Any]]"  [arg-type]
    ... composite_direction = max(direction_scores, key=direction_scores.get)
                                                        ^~~~~~~~~~~~~~~~~~~~
src/thinking/patterns/trend_detector.py:326: error: Argument "confidence" to
"TrendAnalysis" has incompatible type "floating[Any]"; expected "float" 
[arg-type]
                confidence=composite_confidence,
                           ^~~~~~~~~~~~~~~~~~~~
src/thinking/patterns/trend_detector.py:341: error: "SensorySignal" has no
attribute "value"  [attr-defined]
                if direction == 'BULLISH' and signal.value > 0:
                                              ^~~~~~~~~~~~
src/thinking/patterns/trend_detector.py:343: error: "SensorySignal" has no
attribute "value"  [attr-defined]
                elif direction == 'BEARISH' and signal.value < 0:
                                                ^~~~~~~~~~~~
src/thinking/patterns/trend_detector.py:345: error: "SensorySignal" has no
attribute "value"  [attr-defined]
                elif direction == 'NEUTRAL' and abs(signal.value) < 0.1:
                                                    ^~~~~~~~~~~~
src/thinking/patterns/trend_detector.py:354: error: Extra keys ("timestamp",
"analysis_type", "result", "confidence", "metadata") for TypedDict
"AnalysisResult"  [typeddict-unknown-key]
            return AnalysisResult(
                   ^
src/thinking/patterns/cycle_detector.py:18: error: Cannot assign to a type 
[misc]
        ThinkingPattern = SensorySignal = AnalysisResult = object
        ^~~~~~~~~~~~~~~
src/thinking/patterns/cycle_detector.py:18: error: Incompatible types in
assignment (expression has type "type[object]", variable has type
"type[ThinkingPattern]")  [assignment]
        ThinkingPattern = SensorySignal = AnalysisResult = object
        ^
src/thinking/patterns/cycle_detector.py:18: error: Incompatible types in
assignment (expression has type "type[object]", variable has type
"type[SensorySignal]")  [assignment]
        ThinkingPattern = SensorySignal = AnalysisResult = object
        ^
src/thinking/patterns/cycle_detector.py:18: error: Incompatible types in
assignment (expression has type "type[object]", variable has type
"type[AnalysisResult]")  [assignment]
        ThinkingPattern = SensorySignal = AnalysisResult = object
                                                           ^~~~~~
src/thinking/patterns/cycle_detector.py:19: error: Module "src.core.exceptions"
has no attribute "ThinkingException"; maybe "TradingException"?  [attr-defined]
    from src.core.exceptions import ThinkingException
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/patterns/cycle_detector.py:64: error: Extra keys ("timestamp",
"analysis_type", "result", "confidence", "metadata") for TypedDict
"AnalysisResult"  [typeddict-unknown-key]
                return AnalysisResult(
                       ^
src/thinking/patterns/cycle_detector.py:84: error: Argument 1 of "learn" is
incompatible with supertype "src.core.interfaces.ThinkingPattern"; supertype
defines the argument type as "Mapping[str, object]"  [override]
        def learn(self, feedback: dict[str, object]) -> bool:
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/patterns/cycle_detector.py:84: note: This violates the Liskov substitution principle
src/thinking/patterns/cycle_detector.py:84: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
src/thinking/patterns/cycle_detector.py:116: error: "SensorySignal" has no
attribute "signal_type"  [attr-defined]
                if signal.signal_type in ["price_composite", "momentum", "...
                   ^~~~~~~~~~~~~~~~~~
src/thinking/patterns/cycle_detector.py:133: error: "SensorySignal" has no
attribute "value"  [attr-defined]
            values = [s.value for s in signals]
                      ^~~~~~~
src/thinking/patterns/cycle_detector.py:312: error: Value of type variable
"SupportsRichComparisonT" of "min" cannot be "float | floating[Any] | int" 
[type-var]
            strength_confidence = min(signal_strength * 10, 1.0)
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/patterns/cycle_detector.py:316: error: Value of type variable
"SupportsRichComparisonT" of "max" cannot be "floating[Any] | float"  [type-var]
            return float(max(0.0, min(1.0, overall_confidence)))
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/patterns/cycle_detector.py:316: error: Value of type variable
"SupportsRichComparisonT" of "min" cannot be "floating[Any] | float"  [type-var]
            return float(max(0.0, min(1.0, overall_confidence)))
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/patterns/cycle_detector.py:320: error: Extra keys ("timestamp",
"analysis_type", "result", "confidence", "metadata") for TypedDict
"AnalysisResult"  [typeddict-unknown-key]
            return AnalysisResult(
                   ^
src/thinking/patterns/anomaly_detector.py:18: error: Cannot assign to a type 
[misc]
        ThinkingPattern = SensorySignal = AnalysisResult = object
        ^~~~~~~~~~~~~~~
src/thinking/patterns/anomaly_detector.py:18: error: Incompatible types in
assignment (expression has type "type[object]", variable has type
"type[ThinkingPattern]")  [assignment]
        ThinkingPattern = SensorySignal = AnalysisResult = object
        ^
src/thinking/patterns/anomaly_detector.py:18: error: Incompatible types in
assignment (expression has type "type[object]", variable has type
"type[SensorySignal]")  [assignment]
        ThinkingPattern = SensorySignal = AnalysisResult = object
        ^
src/thinking/patterns/anomaly_detector.py:18: error: Incompatible types in
assignment (expression has type "type[object]", variable has type
"type[AnalysisResult]")  [assignment]
        ThinkingPattern = SensorySignal = AnalysisResult = object
                                                           ^~~~~~
src/thinking/patterns/anomaly_detector.py:19: error: Module
"src.core.exceptions" has no attribute "ThinkingException"; maybe
"TradingException"?  [attr-defined]
    from src.core.exceptions import ThinkingException
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/patterns/anomaly_detector.py:68: error: Extra keys ("timestamp",
"analysis_type", "result", "confidence", "metadata") for TypedDict
"AnalysisResult"  [typeddict-unknown-key]
                return AnalysisResult(
                       ^
src/thinking/patterns/anomaly_detector.py:92: error: Argument 1 of "learn" is
incompatible with supertype "src.core.interfaces.ThinkingPattern"; supertype
defines the argument type as "Mapping[str, object]"  [override]
        def learn(self, feedback: dict[str, object]) -> bool:
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/patterns/anomaly_detector.py:92: note: This violates the Liskov substitution principle
src/thinking/patterns/anomaly_detector.py:92: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
src/thinking/patterns/anomaly_detector.py:122: error: "SensorySignal" has no
attribute "signal_type"  [attr-defined]
            price_signals = [s for s in signals if s.signal_type == "price...
                                                   ^~~~~~~~~~~~~
src/thinking/patterns/anomaly_detector.py:135: error: "SensorySignal" has no
attribute "value"  [attr-defined]
            values = [s.value for s in price_signals[-10:]]  # Last 10 sig...
                      ^~~~~~~
src/thinking/patterns/anomaly_detector.py:185: error: "SensorySignal" has no
attribute "signal_type"  [attr-defined]
            volume_signals = [s for s in signals if s.signal_type == "volu...
                                                    ^~~~~~~~~~~~~
src/thinking/patterns/anomaly_detector.py:198: error: "SensorySignal" has no
attribute "value"  [attr-defined]
            values = [s.value for s in volume_signals[-10:]]
                      ^~~~~~~
src/thinking/patterns/anomaly_detector.py:261: error: "SensorySignal" has no
attribute "signal_type"  [attr-defined]
            signal_types = [s.signal_type for s in recent_signals]
                            ^~~~~~~~~~~~~
src/thinking/memory/pattern_memory.py:155: error: Argument 1 to "mean" has
incompatible type "list[object]"; expected
"_SupportsArray[dtype[numpy.bool[builtins.bool] | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool] | integer[Any] | floating[Any]]]] | float | _NestedSequence[float]"
 [arg-type]
            avg_outcome = np.mean(outcomes) if outcomes else 0
                                  ^~~~~~~~
src/thinking/competitive/competitive_intelligence_system.py:21: error: Unused
"type: ignore" comment  [unused-ignore]
        AlgorithmSignature = CompetitorBehavior = CounterStrategy = object...
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/thinking/competitive/competitive_intelligence_system.py:38: error: Unused
"type: ignore" comment  [unused-ignore]
                d = obj.dict()  # type: ignore[attr-defined]
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/competitive/competitive_intelligence_system.py:75: error: Function
is missing a return type annotation  [no-untyped-def]
        def __init__(self):
        ^
src/thinking/competitive/competitive_intelligence_system.py:75: note: Use "-> None" if function does not return a value
src/thinking/competitive/competitive_intelligence_system.py:179: error:
Argument 2 to "_calculate_pattern_similarity" of "AlgorithmFingerprinter" has
incompatible type "object"; expected "dict[str, object]"  [arg-type]
    ...imilarity = self._calculate_pattern_similarity(pattern, known_pattern)
                                                               ^~~~~~~~~~~~~
src/thinking/competitive/competitive_intelligence_system.py:232: error:
Function is missing a return type annotation  [no-untyped-def]
        def __init__(self):
        ^
src/thinking/competitive/competitive_intelligence_system.py:232: note: Use "-> None" if function does not return a value
src/thinking/competitive/competitive_intelligence_system.py:322: error:
Unsupported operand types for / ("object" and "int")  [operator]
                    'aggressiveness': min(behavior_data.get('trade_frequen...
                                          ^
src/thinking/competitive/competitive_intelligence_system.py:323: error:
Unsupported operand types for / ("object" and "float")  [operator]
                    'sophistication': min(behavior_data.get('market_impact...
                                          ^
src/thinking/competitive/competitive_intelligence_system.py:324: error:
Unsupported operand types for - ("object" and "float")  [operator]
                    'consistency': 1.0 - abs(behavior_data.get('win_rate',...
                                             ^
src/thinking/competitive/competitive_intelligence_system.py:327: error:
Incompatible return value type (got "dict[str, object]", expected
"dict[str, float]")  [return-value]
                return metrics
                       ^~~~~~~
src/thinking/competitive/competitive_intelligence_system.py:341: error:
Unsupported operand types for < ("int" and "object")  [operator]
                if behavior_data.get('trade_frequency', 0) > 150:
                   ^
src/thinking/competitive/competitive_intelligence_system.py:344: error:
Unsupported operand types for < ("int" and "object")  [operator]
                if behavior_data.get('avg_position_size', 0) > 1500:
                   ^
src/thinking/competitive/competitive_intelligence_system.py:347: error:
Unsupported operand types for < ("float" and "object")  [operator]
                if behavior_data.get('win_rate', 0) > 0.7:
                   ^
src/thinking/competitive/competitive_intelligence_system.py:350: error:
Unsupported operand types for > ("float" and "object")  [operator]
                if behavior_data.get('market_impact', 0) < 0.0005:
                   ^
src/thinking/competitive/competitive_intelligence_system.py:369: error:
Incompatible types in assignment (expression has type "float", variable has type
"int")  [assignment]
                threat_score += metrics.get('efficiency', 0) * 0.3
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/competitive/competitive_intelligence_system.py:370: error:
Incompatible types in assignment (expression has type "float", variable has type
"int")  [assignment]
                threat_score += metrics.get('aggressiveness', 0) * 0.2
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/competitive/competitive_intelligence_system.py:371: error:
Incompatible types in assignment (expression has type "float", variable has type
"int")  [assignment]
                threat_score += metrics.get('sophistication', 0) * 0.3
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/competitive/competitive_intelligence_system.py:372: error:
Incompatible types in assignment (expression has type "float", variable has type
"int")  [assignment]
                threat_score += metrics.get('consistency', 0) * 0.2
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/competitive/competitive_intelligence_system.py:376: error:
Incompatible types in assignment (expression has type "float", variable has type
"int")  [assignment]
                    threat_score += 0.1
                    ^~~~~~~~~~~~~~~~~~~
src/thinking/competitive/competitive_intelligence_system.py:378: error:
Incompatible types in assignment (expression has type "float", variable has type
"int")  [assignment]
                    threat_score += 0.2
                    ^~~~~~~~~~~~~~~~~~~
src/thinking/competitive/competitive_intelligence_system.py:399: error:
Unsupported left operand type for * ("object")  [operator]
                volume = behavior_data.get('avg_position_size', 0) * behav...
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/thinking/competitive/competitive_intelligence_system.py:417: error:
Unsupported left operand type for * ("object")  [operator]
                performance = win_rate * avg_return * 252  # Annualized
                              ^~~~~~~~~~~~~~~~~~~~~
src/thinking/competitive/competitive_intelligence_system.py:429: error:
Function is missing a return type annotation  [no-untyped-def]
        def __init__(self):
        ^
src/thinking/competitive/competitive_intelligence_system.py:429: note: Use "-> None" if function does not return a value
src/thinking/competitive/competitive_intelligence_system.py:532: error:
"object" has no attribute "threat_level"  [attr-defined]
                if behavior.threat_level == 'high':
                   ^~~~~~~~~~~~~~~~~~~~~
src/thinking/competitive/competitive_intelligence_system.py:533: error:
Unsupported operand types for * ("object" and "float")  [operator]
                    customized['effectiveness'] *= 1.2
                    ^
src/thinking/competitive/competitive_intelligence_system.py:538: error:
Unsupported target for indexed assignment ("object")  [index]
                    customized['parameters']['latency_optimization'] = Tru...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/competitive/competitive_intelligence_system.py:541: error:
"object" has no attribute "market_share"  [attr-defined]
                threat_score = float(behavior.market_share) * float(behavi...
                                     ^~~~~~~~~~~~~~~~~~~~~
src/thinking/competitive/competitive_intelligence_system.py:541: error:
"object" has no attribute "performance"  [attr-defined]
    ...eat_score = float(behavior.market_share) * float(behavior.performance)
                                                        ^~~~~~~~~~~~~~~~~~~~
src/thinking/competitive/competitive_intelligence_system.py:556: error: No
overload variant of "get" of "dict" matches argument types "object", "str" 
[call-overload]
                customized['timeline'] = complexity_map.get(
                                         ^
src/thinking/competitive/competitive_intelligence_system.py:556: note: Possible overload variants:
src/thinking/competitive/competitive_intelligence_system.py:556: note:     def get(self, str, None = ..., /) -> str | None
src/thinking/competitive/competitive_intelligence_system.py:556: note:     def get(self, str, str, /) -> str
src/thinking/competitive/competitive_intelligence_system.py:556: note:     def [_T] get(self, str, _T, /) -> str | _T
src/thinking/competitive/competitive_intelligence_system.py:583: error:
Unsupported operand types for * ("object" and "float")  [operator]
                effectiveness = base_effectiveness * threat_multiplier.get...
                                ^
src/thinking/competitive/competitive_intelligence_system.py:584: error:
"object" has no attribute "threat_level"  [attr-defined]
                    behavior.threat_level,
                    ^~~~~~~~~~~~~~~~~~~~~
src/thinking/competitive/competitive_intelligence_system.py:598: error:
Function is missing a return type annotation  [no-untyped-def]
        def __init__(self):
        ^
src/thinking/competitive/competitive_intelligence_system.py:598: note: Use "-> None" if function does not return a value
src/thinking/competitive/competitive_intelligence_system.py:616: error:
Argument 1 to "float" has incompatible type "object"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
                ]) + float(our_performance.get('market_share', 0))
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/competitive/competitive_intelligence_system.py:616: note: Left operand is of type "float | Literal[0]"
src/thinking/competitive/competitive_intelligence_system.py:639: error:
Argument 1 to "float" has incompatible type "object"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
                    'our_share': float(our_performance.get('market_share',...
                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/competitive/competitive_intelligence_system.py:721: error:
Argument 1 to "float" has incompatible type "object"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
                our_share = float(our_performance.get('market_share', 0))
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/competitive/competitive_intelligence_system.py:856: error:
Incompatible return value type (got "dict[str, dict[str, Sequence[str]]]",
expected "dict[str, object]")  [return-value]
                return self.algorithm_fingerprinter.known_patterns
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/competitive/competitive_intelligence_system.py:856: note: "dict" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance
src/thinking/competitive/competitive_intelligence_system.py:856: note: Consider using "Mapping" instead, which is covariant in the value type
src/thinking/analysis/correlation_analyzer.py:16: error: Module
"src.core.exceptions" has no attribute "ThinkingException"; maybe
"TradingException"?  [attr-defined]
    from src.core.exceptions import ThinkingException
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/analysis/correlation_analyzer.py:21: error: Cannot assign to a
type  [misc]
        ThinkingPattern = SensorySignal = AnalysisResult = object
        ^~~~~~~~~~~~~~~
src/thinking/analysis/correlation_analyzer.py:21: error: Incompatible types in
assignment (expression has type "type[object]", variable has type
"type[ThinkingPattern]")  [assignment]
        ThinkingPattern = SensorySignal = AnalysisResult = object
        ^
src/thinking/analysis/correlation_analyzer.py:21: error: Incompatible types in
assignment (expression has type "type[object]", variable has type
"type[SensorySignal]")  [assignment]
        ThinkingPattern = SensorySignal = AnalysisResult = object
        ^
src/thinking/analysis/correlation_analyzer.py:21: error: Incompatible types in
assignment (expression has type "type[object]", variable has type
"type[AnalysisResult]")  [assignment]
        ThinkingPattern = SensorySignal = AnalysisResult = object
                                                           ^~~~~~
src/thinking/analysis/correlation_analyzer.py:53: error: Extra keys
("timestamp", "analysis_type", "result", "confidence", "metadata") for TypedDict
"AnalysisResult"  [typeddict-unknown-key]
                return AnalysisResult(
                       ^
src/thinking/analysis/correlation_analyzer.py:76: error: Argument 1 of "learn"
is incompatible with supertype "src.core.interfaces.ThinkingPattern"; supertype
defines the argument type as "Mapping[str, object]"  [override]
        def learn(self, feedback: dict[str, object]) -> bool:
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/analysis/correlation_analyzer.py:76: note: This violates the Liskov substitution principle
src/thinking/analysis/correlation_analyzer.py:76: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
src/thinking/analysis/correlation_analyzer.py:98: error: "SensorySignal" has no
attribute "signal_type"  [attr-defined]
                signal_type = signal.signal_type
                              ^~~~~~~~~~~~~~~~~~
src/thinking/analysis/correlation_analyzer.py:103: error: "SensorySignal" has
no attribute "value"  [attr-defined]
    ...         self._signal_history[signal_type].append(float(signal.value))
                                                               ^~~~~~~~~~~~
src/thinking/adversarial/red_team_ai.py:20: error: Unused "type: ignore"
comment  [unused-ignore]
        StrategyAnalysis = AttackResult = ExploitResult = object  # type: ...
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/thinking/adversarial/red_team_ai.py:38: error: Unused "type: ignore"
comment  [unused-ignore]
                d = obj.dict()  # type: ignore[attr-defined]
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/adversarial/red_team_ai.py:59: error: Function is missing a return
type annotation  [no-untyped-def]
        def __init__(self):
        ^
src/thinking/adversarial/red_team_ai.py:59: note: Use "-> None" if function does not return a value
src/thinking/adversarial/red_team_ai.py:148: error: Argument 1 to "mean" has
incompatible type "list[object]"; expected
"_SupportsArray[dtype[numpy.bool[builtins.bool] | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool] | integer[Any] | floating[Any]]]] | float | _NestedSequence[float]"
 [arg-type]
                    metrics[metric] = np.mean(values)
                                              ^~~~~~
src/thinking/adversarial/red_team_ai.py:150: error: Incompatible return value
type (got "dict[str, floating[Any]]", expected "dict[str, float]") 
[return-value]
                return metrics
                       ^~~~~~~
src/thinking/adversarial/red_team_ai.py:201: error: Function is missing a
return type annotation  [no-untyped-def]
        def __init__(self):
        ^
src/thinking/adversarial/red_team_ai.py:201: note: Use "-> None" if function does not return a value
src/thinking/adversarial/red_team_ai.py:249: error: Unsupported operand types
for < ("float" and "object")  [operator]
                    return behavior_profile.get('volatility_sensitivity', ...
                           ^
src/thinking/adversarial/red_team_ai.py:252: error: Unsupported operand types
for < ("float" and "object")  [operator]
                    return behavior_profile.get('trend_following_strength'...
                           ^
src/thinking/adversarial/red_team_ai.py:255: error: Unsupported operand types
for < ("float" and "object")  [operator]
                    return behavior_profile.get('mean_reversion_tendency',...
                           ^
src/thinking/adversarial/red_team_ai.py:273: error: Argument 1 to "abs" has
incompatible type "object"; expected "SupportsAbs[Never]"  [arg-type]
                    if abs(value) > 2.0:  # Extreme value threshold
                           ^~~~~
src/thinking/adversarial/red_team_ai.py:286: error: Function is missing a
return type annotation  [no-untyped-def]
        def __init__(self):
        ^
src/thinking/adversarial/red_team_ai.py:286: note: Use "-> None" if function does not return a value
src/thinking/adversarial/red_team_ai.py:321: error: Argument 1 to
"_generate_attack_parameters" of "AttackGenerator" has incompatible type
"dict[str, str]"; expected "dict[str, object]"  [arg-type]
                    template,
                    ^~~~~~~~
src/thinking/adversarial/red_team_ai.py:321: note: "dict" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance
src/thinking/adversarial/red_team_ai.py:321: note: Consider using "Mapping" instead, which is covariant in the value type
src/thinking/adversarial/red_team_ai.py:395: error: Function is missing a
return type annotation  [no-untyped-def]
        def __init__(self):
        ^
src/thinking/adversarial/red_team_ai.py:395: note: Use "-> None" if function does not return a value
src/thinking/adversarial/red_team_ai.py:599: error: Incompatible return value
type (got "dict[str, Collection[Collection[str]]]", expected
"dict[str, object]")  [return-value]
                return report
                       ^~~~~~
src/thinking/adversarial/red_team_ai.py:599: note: "dict" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance
src/thinking/adversarial/red_team_ai.py:599: note: Consider using "Mapping" instead, which is covariant in the value type
src/thinking/adversarial/red_team_ai.py:599: note: Perhaps you need a type annotation for "report"? Suggestion: "dict[str, object]"
src/sentient/memory/faiss_pattern_memory.py:34: error: Returning Any from
function declared to return "dict[str, float]"  [no-any-return]
            return self.metadata.get("features", {})
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sentient/memory/faiss_pattern_memory.py:39: error: Returning Any from
function declared to return "dict[str, float]"  [no-any-return]
            return self.metadata.get("outcome", {})
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sentient/memory/faiss_pattern_memory.py:56: error: Need type annotation for
"metadata" (hint: "metadata: dict[<type>, <type>] = ...")  [var-annotated]
            self.metadata = {}
            ^~~~~~~~~~~~~
src/sentient/memory/faiss_pattern_memory.py:62: error: Function is missing a
return type annotation  [no-untyped-def]
        def _initialize_index(self):
        ^
src/sentient/memory/faiss_pattern_memory.py:62: note: Use "-> None" if function does not return a value
src/sentient/memory/faiss_pattern_memory.py:65: error: Incompatible types in
assignment (expression has type "Index", variable has type "None")  [assignment]
                self.index = faiss.read_index(str(self.index_path))
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sentient/memory/faiss_pattern_memory.py:66: error: "None" has no attribute
"ntotal"  [attr-defined]
    ...           logger.info(f"Loaded FAISS index with {self.index.ntotal} e...
                                                        ^~~~~~~~~~~~~~~~~~
src/sentient/memory/faiss_pattern_memory.py:69: error: Incompatible types in
assignment (expression has type "IndexFlatL2", variable has type "None") 
[assignment]
                self.index = faiss.IndexFlatL2(self.dimension)
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sentient/memory/faiss_pattern_memory.py:72: error: Function is missing a
return type annotation  [no-untyped-def]
        def _load_metadata(self):
        ^
src/sentient/memory/faiss_pattern_memory.py:72: note: Use "-> None" if function does not return a value
src/sentient/memory/faiss_pattern_memory.py:79: error: Function is missing a
return type annotation  [no-untyped-def]
        def _save_metadata(self):
        ^
src/sentient/memory/faiss_pattern_memory.py:79: note: Use "-> None" if function does not return a value
src/sentient/memory/faiss_pattern_memory.py:95: error: "None" has no attribute
"add"  [attr-defined]
            self.index.add(vector.reshape(1, -1))
            ^~~~~~~~~~~~~~
src/sentient/memory/faiss_pattern_memory.py:106: error: "None" has no attribute
"ntotal"  [attr-defined]
                "index_position": self.index.ntotal - 1,
                                  ^~~~~~~~~~~~~~~~~
src/sentient/memory/faiss_pattern_memory.py:113: error: Argument 1 to
"write_index" has incompatible type "None"; expected "Index"  [arg-type]
            faiss.write_index(self.index, str(self.index_path))
                              ^~~~~~~~~~
src/sentient/memory/faiss_pattern_memory.py:129: error: "None" has no attribute
"search"  [attr-defined]
            distances, indices = self.index.search(query_vector.reshape(1,...
                                 ^~~~~~~~~~~~~~~~~
src/sentient/memory/faiss_pattern_memory.py:159: error: "None" has no attribute
"ntotal"  [attr-defined]
                "total_memories": self.index.ntotal,
                                  ^~~~~~~~~~~~~~~~~
src/sentient/memory/faiss_pattern_memory.py:166: error: Function is missing a
return type annotation  [no-untyped-def]
        def clear_memory(self):
        ^
src/sentient/memory/faiss_pattern_memory.py:166: note: Use "-> None" if function does not return a value
src/sentient/memory/faiss_pattern_memory.py:168: error: Incompatible types in
assignment (expression has type "IndexFlatL2", variable has type "None") 
[assignment]
            self.index = faiss.IndexFlatL2(self.dimension)
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sentient/learning/real_time_learning_engine.py:128: error: Returning Any
from function declared to return "bool"  [no-any-return]
            return price_change > 0.001 and volume > 3 * avg_volume
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/volume_organ.py:15: error: Module "src.core.base" has no
attribute "SensoryOrgan"  [attr-defined]
    from src.core.base import MarketData, SensoryOrgan
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/volume_organ.py:16: error: Module "src.core.exceptions" has
no attribute "SensoryException"; maybe "ResourceException"?  [attr-defined]
    from src.core.exceptions import SensoryException
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/price_organ.py:15: error: Module "src.core.base" has no
attribute "SensoryOrgan"  [attr-defined]
    from src.core.base import MarketData, SensoryOrgan
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/price_organ.py:16: error: Module "src.core.exceptions" has
no attribute "SensoryException"; maybe "ResourceException"?  [attr-defined]
    from src.core.exceptions import SensoryException
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/orderbook_organ.py:15: error: Module "src.core.base" has no
attribute "SensoryOrgan"  [attr-defined]
    from src.core.base import MarketData, SensoryOrgan
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/orderbook_organ.py:16: error: Module "src.core.exceptions"
has no attribute "SensoryException"; maybe "ResourceException"?  [attr-defined]
    from src.core.exceptions import SensoryException
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/macro_intelligence.py:303: error: Returning Any
from function declared to return "MarketRegime"  [no-any-return]
                return MarketRegime.HIGH_VOLATILITY
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/macro_intelligence.py:303: error:
"type[MarketRegime]" has no attribute "HIGH_VOLATILITY"  [attr-defined]
                return MarketRegime.HIGH_VOLATILITY
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/macro_intelligence.py:305: error: Returning Any
from function declared to return "MarketRegime"  [no-any-return]
                return MarketRegime.BULLISH
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/macro_intelligence.py:305: error:
"type[MarketRegime]" has no attribute "BULLISH"  [attr-defined]
                return MarketRegime.BULLISH
                       ^~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/macro_intelligence.py:307: error: Returning Any
from function declared to return "MarketRegime"  [no-any-return]
                return MarketRegime.BEARISH
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/macro_intelligence.py:307: error:
"type[MarketRegime]" has no attribute "BEARISH"  [attr-defined]
                return MarketRegime.BEARISH
                       ^~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/macro_intelligence.py:309: error: Returning Any
from function declared to return "MarketRegime"  [no-any-return]
                return MarketRegime.RANGING
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/macro_intelligence.py:309: error:
"type[MarketRegime]" has no attribute "RANGING"  [attr-defined]
                return MarketRegime.RANGING
                       ^~~~~~~~~~~~~~~~~~~~
src/ecosystem/coordination/coordination_engine.py:299: error: Return type
"Coroutine[Any, Any, JSONObject]" of "get_portfolio_summary" incompatible with
return type "Coroutine[Any, Any, dict[str, object]]" in supertype
"src.core.interfaces.ICoordinationEngine"  [override]
        async def get_portfolio_summary(self) -> JSONObject:
        ^
src/data_integration/data_fusion.py:103: error: "MarketData" has no attribute
"volatility"  [attr-defined]
                        volatility=data.volatility
                                   ^~~~~~~~~~~~~~~
src/data_integration/data_fusion.py:124: error: Need type annotation for
"aligned_data" (hint: "aligned_data: dict[<type>, <type>] = ...") 
[var-annotated]
            aligned_data = {}
            ^~~~~~~~~~~~
src/data_integration/data_fusion.py:163: error: Incompatible return value type
(got "tuple[None, list[str]]", expected "tuple[MarketData, list[str]]") 
[return-value]
                return None, []
                       ^~~~~~~~
src/data_integration/data_fusion.py:214: error: Incompatible types in
assignment (expression has type "float", variable has type "int")  [assignment]
                total_weight += weight
                ^~~~~~~~~~~~~~~~~~~~~~
src/data_integration/data_fusion.py:216: error: Incompatible types in
assignment (expression has type "float", variable has type "int")  [assignment]
                weighted_bid += data.bid * weight
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/data_integration/data_fusion.py:217: error: Incompatible types in
assignment (expression has type "float", variable has type "int")  [assignment]
                weighted_ask += data.ask * weight
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/data_integration/data_fusion.py:218: error: Incompatible types in
assignment (expression has type "float", variable has type "int")  [assignment]
                weighted_volume += data.volume * weight
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/data_integration/data_fusion.py:219: error: "MarketData" has no attribute
"volatility"  [attr-defined]
                weighted_volatility += data.volatility * weight
                                       ^~~~~~~~~~~~~~~
src/data_integration/data_fusion.py:251: error: "MarketData" has no attribute
"volatility"  [attr-defined]
            volatilities = [data.volatility for _, data, _ in data_points]
                            ^~~~~~~~~~~~~~~
src/data_integration/data_fusion.py:269: error: "MarketData" has no attribute
"volatility"  [attr-defined]
            volatilities = [data.volatility for _, data, _ in data_points]
                            ^~~~~~~~~~~~~~~
src/data_integration/data_fusion.py:366: error: Argument "volume" to
"FusedDataPoint" has incompatible type "float"; expected "int"  [arg-type]
                    volume=resolved_data.volume,
                           ^~~~~~~~~~~~~~~~~~~~
src/data_integration/data_fusion.py:367: error: "MarketData" has no attribute
"volatility"  [attr-defined]
                    volatility=resolved_data.volatility,
                               ^~~~~~~~~~~~~~~~~~~~~~~~
src/data_integration/data_fusion.py:439: error: Incompatible types in
assignment (expression has type "float", variable has type "int")  [assignment]
                total_weight += weight
                ^~~~~~~~~~~~~~~~~~~~~~
src/data_integration/data_fusion.py:440: error: Incompatible types in
assignment (expression has type "float", variable has type "int")  [assignment]
                weighted_confidence += confidence * weight
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/data_integration/data_fusion.py:443: error: Incompatible return value type
(got "floating[Any]", expected "float")  [return-value]
                return np.mean([conf for _, _, conf in data_points])
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/core/population_manager.py:46: error: List comprehension has incompatible
type List[object]; expected List[DecisionGenome]  [misc]
            self.population = [provider.from_legacy(genome_factory()) for ...
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/core/population_manager.py:77: error: List comprehension has incompatible
type List[object]; expected List[DecisionGenome]  [misc]
            self.population = [provider.from_legacy(g) for g in new_popula...
                               ^~~~~~~~~~~~~~~~~~~~~~~
src/core/population_manager.py:192: error: Argument 1 to "append" of "list" has
incompatible type "object"; expected "DecisionGenome"  [arg-type]
                    self.population.append(genome)
                                           ^~~~~~
src/core/population_manager.py:227: error: Argument 1 to "append" of "list" has
incompatible type "object"; expected "DecisionGenome"  [arg-type]
                    new_population.append(offspring)
                                          ^~~~~~~~~
src/sentient/sentient_predator.py:40: error: Function is missing a return type
annotation  [no-untyped-def]
        async def start(self):
        ^
src/sentient/sentient_predator.py:40: note: Use "-> None" if function does not return a value
src/sentient/sentient_predator.py:45: error: Function is missing a return type
annotation  [no-untyped-def]
        async def stop(self):
        ^
src/sentient/sentient_predator.py:45: note: Use "-> None" if function does not return a value
src/sentient/sentient_predator.py:178: error: Function is missing a return type
annotation  [no-untyped-def]
        async def reset(self):
        ^
src/sentient/sentient_predator.py:178: note: Use "-> None" if function does not return a value
src/intelligence/sentient_adaptation.py:141: error: Missing positional argument
"config" in call to "RealTimeLearningEngine"  [call-arg]
            self.real_time_learner = RealTimeLearningEngine()
                                     ^~~~~~~~~~~~~~~~~~~~~~~~
src/intelligence/sentient_adaptation.py:142: error: Missing positional argument
"config" in call to "FAISSPatternMemory"  [call-arg]
            self.pattern_memory = FAISSPatternMemory()
                                  ^~~~~~~~~~~~~~~~~~~~
src/intelligence/sentient_adaptation.py:144: error: Missing positional argument
"config" in call to "AdaptationController"  [call-arg]
            self.adaptation_controller = AdaptationController()
                                         ^~~~~~~~~~~~~~~~~~~~~~
src/intelligence/sentient_adaptation.py:148: error: Need type annotation for
"recent_performance" (hint: "recent_performance: list[<type>] = ...") 
[var-annotated]
            self.recent_performance = []
            ^~~~~~~~~~~~~~~~~~~~~~~
src/intelligence/sentient_adaptation.py:158: error: "RealTimeLearningEngine"
has no attribute "process_outcome"  [attr-defined]
            learning_signal = await self.real_time_learner.process_outcome...
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/intelligence/sentient_adaptation.py:163: error: "FAISSPatternMemory" has no
attribute "store_pattern"  [attr-defined]
            await self.pattern_memory.store_pattern(
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/intelligence/sentient_adaptation.py:178: error: Unexpected keyword argument
"current_strategy_state" for "generate_adaptations" of "AdaptationController" 
[call-arg]
                adaptations = await self.adaptation_controller.generate_ad...
                                    ^
src/sentient/adaptation/adaptation_controller.py:66: note: "generate_adaptations" of "AdaptationController" defined here
src/intelligence/sentient_adaptation.py:182: error: Argument 1 to
"apply_adaptations" of "SentientAdaptationEngine" has incompatible type
"list[TacticalAdaptation]"; expected "dict[str, Any]"  [arg-type]
                await self.apply_adaptations(adaptations)
                                             ^~~~~~~~~~~
src/intelligence/sentient_adaptation.py:185: error: Incompatible types in
assignment (expression has type "datetime", variable has type "None") 
[assignment]
                self.last_adaptation = datetime.utcnow()
                                       ^~~~~~~~~~~~~~~~~
src/intelligence/sentient_adaptation.py:204: error: "AdaptationController" has
no attribute "risk_parameters"  [attr-defined]
                'risk_parameters': self.adaptation_controller.risk_paramet...
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/intelligence/red_team_ai.py:1026: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
src/intelligence/red_team_ai.py:1035: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
src/intelligence/red_team_ai.py:1043: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
src/pnl.py:200: error: "Instrument" has no attribute "swap_time" 
[attr-defined]
            swap_hour, swap_minute = map(int, instrument.swap_time.split("...
                                              ^~~~~~~~~~~~~~~~~~~~
src/pnl.py:213: error: "Instrument" has no attribute "long_swap_rate" 
[attr-defined]
                    swap_fee = instrument.long_swap_rate * abs(self.quanti...
                               ^~~~~~~~~~~~~~~~~~~~~~~~~
src/pnl.py:215: error: "Instrument" has no attribute "short_swap_rate" 
[attr-defined]
                    swap_fee = instrument.short_swap_rate * abs(self.quant...
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/adversarial/market_gan.py:177: error: Argument 2 to
"train_generator" of "AdversarialTrainer" has incompatible type
"list[dict[str, float]]"; expected "list[object]"  [arg-type]
                        self.generator, norm_sr, target_failure_rate=0.3
                                        ^~~~~~~
src/thinking/adversarial/market_gan.py:177: note: "list" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance
src/thinking/adversarial/market_gan.py:177: note: Consider using "Sequence" instead, which is covariant
src/thinking/adversarial/market_gan.py:182: error: Argument 1 to
"train_discriminator" of "AdversarialTrainer" has incompatible type "list[str]";
expected "list[object]"  [arg-type]
                        strategy_population, synthetic_scenarios, norm_sr
                        ^~~~~~~~~~~~~~~~~~~
src/thinking/adversarial/market_gan.py:182: note: "list" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance
src/thinking/adversarial/market_gan.py:182: note: Consider using "Sequence" instead, which is covariant
src/thinking/adversarial/market_gan.py:182: error: Argument 2 to
"train_discriminator" of "AdversarialTrainer" has incompatible type
"list[MarketScenario]"; expected "list[object]"  [arg-type]
                        strategy_population, synthetic_scenarios, norm_sr
                                             ^~~~~~~~~~~~~~~~~~~
src/thinking/adversarial/market_gan.py:182: error: Argument 3 to
"train_discriminator" of "AdversarialTrainer" has incompatible type
"list[dict[str, float]]"; expected "list[object]"  [arg-type]
                        strategy_population, synthetic_scenarios, norm_sr
                                                                  ^~~~~~~
src/thinking/adversarial/market_gan.py:194: error: Argument 4 to
"_store_training_results" of "MarketGAN" has incompatible type "list[object]";
expected "list[str]"  [arg-type]
    ..._store_training_results(epoch, survival_results, validation, improved)
                                                                    ^~~~~~~~
src/thinking/adversarial/market_gan.py:198: error: Incompatible return value
type (got "list[object]", expected "list[str]")  [return-value]
                return improved_strategies
                       ^~~~~~~~~~~~~~~~~~~
src/thinking/adaptation/tactical_adaptation_engine.py:15: error: Unused
"type: ignore" comment  [unused-ignore]
        LearningSignal = TacticalAdaptation = ContextPacket = object  # ty...
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/thinking/adaptation/tactical_adaptation_engine.py:55: error: Need type
annotation for "adaptations" (hint: "adaptations: list[<type>] = ...") 
[var-annotated]
                adaptations = []
                ^~~~~~~~~~~
src/thinking/adaptation/tactical_adaptation_engine.py:58: error:
"FAISSPatternMemory" has no attribute "find_similar_experiences"  [attr-defined]
                similar_experiences = await self.pattern_memory.find_simil...
                                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/thinking/adaptation/tactical_adaptation_engine.py:107: error: Missing type
parameters for generic type "List"  [type-arg]
            similar_experiences: List,
                                 ^
src/thinking/adaptation/tactical_adaptation_engine.py:122: error: Need type
annotation for "regime_distribution" (hint:
"regime_distribution: dict[<type>, <type>] = ...")  [var-annotated]
                regime_distribution = {}
                ^~~~~~~~~~~~~~~~~~~
src/thinking/adaptation/tactical_adaptation_engine.py:167: error: Unsupported
operand types for < ("int" and "object")  [operator]
                if avg_outcome > 0 and current_outcome < 0:
                   ^
src/thinking/adaptation/tactical_adaptation_engine.py:167: error: Unsupported
operand types for > ("int" and "object")  [operator]
                if avg_outcome > 0 and current_outcome < 0:
                                       ^
src/thinking/adaptation/tactical_adaptation_engine.py:171: error: Unsupported
operand types for > ("int" and "object")  [operator]
                elif avg_outcome < 0 and current_outcome > 0:
                     ^
src/thinking/adaptation/tactical_adaptation_engine.py:171: error: Unsupported
operand types for < ("int" and "object")  [operator]
                elif avg_outcome < 0 and current_outcome > 0:
                                         ^
src/thinking/adaptation/tactical_adaptation_engine.py:231: error: Unsupported
operand types for > ("float" and "object")  [operator]
                if win_rate < 0.4:
                   ^
src/thinking/adaptation/tactical_adaptation_engine.py:238: error: Unsupported
operand types for - ("int" and "object")  [operator]
                        confidence=Decimal(str(1 - win_rate)),
                                                   ^~~~~~~~
src/thinking/adaptation/tactical_adaptation_engine.py:247: error: Unsupported
operand types for - ("int" and "object")  [operator]
                        confidence=Decimal(str(1 - win_rate)),
                                                   ^~~~~~~~
src/thinking/adaptation/tactical_adaptation_engine.py:251: error: Unsupported
operand types for < ("float" and "object")  [operator]
                elif win_rate > 0.7:
                     ^
src/integration/component_integrator.py:23: error: Unused "type: ignore"
comment  [unused-ignore]
        from src.core import PopulationManager, SensoryOrgan, RiskManager ...
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/integration/component_integrator.py:25: error: Cannot assign to a type 
[misc]
        PopulationManager = SensoryOrgan = RiskManager = None  # type: ign...
        ^~~~~~~~~~~~~~~~~
src/integration/component_integrator.py:25: note: Error code "misc" not covered by "type: ignore" comment
src/integration/component_integrator.py:89: error: Unused "type: ignore"
comment  [unused-ignore]
                population_manager = PopulationManager(population_size=100...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/integration/component_integrator.py:95: error: Unused "type: ignore"
comment  [unused-ignore]
                risk_manager = RiskManager()  # type: ignore[call-arg]
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/integration/component_integrator.py:189: error: Unused "type: ignore"
comment  [unused-ignore]
                    self.components[component_name] = PopulationManager(po...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/integration/component_integrator.py:191: error: Unused "type: ignore"
comment  [unused-ignore]
                    self.components[component_name] = RiskManager()  # typ...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/trading/trading_manager.py:63: error: Missing positional arguments
"risk_per_trade", "stop_loss_pct" in call to "position_size"  [call-arg]
            self.position_sizer = PositionSizer(risk_per_trade)
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/trading_manager.py:63: error: Argument 1 to "position_size" has
incompatible type "float"; expected "Decimal"  [arg-type]
            self.position_sizer = PositionSizer(risk_per_trade)
                                                ^~~~~~~~~~~~~~
src/trading/trading_manager.py:64: error: "None" not callable  [misc]
            self.risk_gateway = RiskGateway(
                                ^
src/trading/trading_manager.py:94: error: "PortfolioMonitor" has no attribute
"get_state"  [attr-defined]
                portfolio_state = self.portfolio_monitor.get_state()
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/trading_manager.py:110: error: "PortfolioMonitor" has no attribute
"increment_positions"  [attr-defined]
                    self.portfolio_monitor.increment_positions()
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/trading_manager.py:143: error: "PortfolioMonitor" has no attribute
"get_state"  [attr-defined]
                "portfolio_state": self.portfolio_monitor.get_state()
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/validation/real_market_validation.py:141: error: Returning Any from
function declared to return "datetime | None"  [no-any-return]
                                return pd.to_datetime(ts).to_pydatetime()
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/validation/real_market_validation.py:242: error: Argument 1 to
"detect_regime" of "RegimeClassifier" has incompatible type "DataFrame";
expected "Mapping[str, object]"  [arg-type]
                        window
                        ^~~~~~
src/validation/real_market_validation.py:342: error: Argument 1 to
"detect_regime" of "RegimeClassifier" has incompatible type "DataFrame";
expected "Mapping[str, object]"  [arg-type]
                _ = await self.regime_classifier.detect_regime(data)
                                                               ^~~~
src/validation/real_market_validation.py:659: error: Function is missing a
return type annotation  [no-untyped-def]
        def print_comprehensive_report(self, report: Dict[str, Any]):
        ^
src/validation/real_market_validation.py:691: error: Function is missing a
return type annotation  [no-untyped-def]
    async def main():
    ^
src/validation/real_market_validation.py:691: note: Use "-> None" if function does not return a value
src/validation/phase2d_simple_integration.py:53: error: Missing type parameters
for generic type "dict"  [type-arg]
        async def test_real_data_integration(self) -> dict:
                                                      ^
src/validation/phase2d_simple_integration.py:66: error: Argument 1 to "len" has
incompatible type "object"; expected "Sized"  [arg-type]
                        if data is not None and len(data) > 10:
                                                    ^~~~
src/validation/phase2d_simple_integration.py:68: error: Argument 1 to "len" has
incompatible type "object"; expected "Sized"  [arg-type]
    ...           {"symbol": symbol, "data_points": len(data), "success": Tru...
                                                        ^~~~
src/validation/phase2d_simple_integration.py:87: error: Argument 1 to
"detect_regime" of "RegimeClassifier" has incompatible type "object"; expected
"Mapping[str, object]"  [arg-type]
    ... regime_result = await self.regime_classifier.detect_regime(test_data)
                                                                   ^~~~~~~~~
src/validation/phase2d_simple_integration.py:118: error: Missing type
parameters for generic type "dict"  [type-arg]
        async def test_performance_metrics(self) -> dict:
                                                    ^
src/validation/phase2d_simple_integration.py:125: error: Argument 1 to "len"
has incompatible type "object"; expected "Sized"  [arg-type]
                if data is None or len(data) < 20:
                                       ^~~~
src/validation/phase2d_simple_integration.py:133: error: Unsupported target for
indexed assignment ("object")  [index]
                data["returns"] = data["close"].pct_change()
                ^~~~~~~~~~~~~~~
src/validation/phase2d_simple_integration.py:133: error: Value of type "object"
is not indexable  [index]
                data["returns"] = data["close"].pct_change()
                                  ^~~~~~~~~~~~~
src/validation/phase2d_simple_integration.py:134: error: "object" has no
attribute "dropna"  [attr-defined]
                data = data.dropna()
                       ^~~~~~~~~~~
src/validation/phase2d_simple_integration.py:172: error: Missing type
parameters for generic type "dict"  [type-arg]
        async def test_risk_management_integration(self) -> dict:
                                                            ^
src/validation/phase2d_simple_integration.py:220: error: Missing type
parameters for generic type "dict"  [type-arg]
        async def test_concurrent_operations(self) -> dict:
                                                      ^
src/validation/phase2d_simple_integration.py:262: error: Missing type
parameters for generic type "dict"  [type-arg]
        async def _fetch_symbol_async(self, symbol: str) -> dict:
                                                            ^
src/validation/phase2d_simple_integration.py:266: error: Argument 1 to "len"
has incompatible type "object"; expected "Sized"  [arg-type]
                if data is not None and len(data) > 0:
                                            ^~~~
src/validation/phase2d_simple_integration.py:267: error: Argument 1 to "len"
has incompatible type "object"; expected "Sized"  [arg-type]
    ...  return {"success": True, "symbol": symbol, "data_points": len(data)}
                                                                       ^~~~
src/validation/phase2d_simple_integration.py:297: error: Missing type
parameters for generic type "dict"  [type-arg]
        async def run_phase2d_validation(self) -> dict:
                                                  ^
src/validation/phase2d_simple_integration.py:342: error: Missing type
parameters for generic type "dict"  [type-arg]
    ...lidate_real_success_criteria(self, results: List[dict]) -> Dict[str, A...
                                                        ^
src/validation/phase2d_integration_validator.py:47: error: Need type annotation
for "results" (hint: "results: list[<type>] = ...")  [var-annotated]
            self.results = []
            ^~~~~~~~~~~~
src/validation/phase2d_integration_validator.py:67: error: Argument 1 to "len"
has incompatible type "object"; expected "Sized"  [arg-type]
                        if data is not None and len(data) > 0:
                                                    ^~~~
src/validation/phase2d_integration_validator.py:80: error: Argument 1 to
"detect_regime" of "RegimeClassifier" has incompatible type "object"; expected
"Mapping[str, object]"  [arg-type]
    ... regime_result = await self.regime_classifier.detect_regime(test_data)
                                                                   ^~~~~~~~~
src/validation/phase2d_integration_validator.py:93: error: Cannot instantiate
protocol class "DecisionGenome"  [misc]
                    genome = DecisionGenome()  # placeholder instance for ...
                             ^~~~~~~~~~~~~~~~
src/validation/phase2d_integration_validator.py:96: error: Argument 2 to
"_evaluate_genome_with_real_data" of "Phase2DIntegrationValidator" has
incompatible type "object"; expected "DataFrame"  [arg-type]
    ..._score = await self._evaluate_genome_with_real_data(genome, test_data)
                                                                   ^~~~~~~~~
src/validation/phase2d_integration_validator.py:173: error: Argument 1 to "len"
has incompatible type "object"; expected "Sized"  [arg-type]
                if data is None or len(data) < 20:
                                       ^~~~
src/validation/phase2d_integration_validator.py:181: error: Unsupported target
for indexed assignment ("object")  [index]
                data["returns"] = data["close"].pct_change()
                ^~~~~~~~~~~~~~~
src/validation/phase2d_integration_validator.py:181: error: Value of type
"object" is not indexable  [index]
                data["returns"] = data["close"].pct_change()
                                  ^~~~~~~~~~~~~
src/validation/phase2d_integration_validator.py:182: error: "object" has no
attribute "dropna"  [attr-defined]
                data = data.dropna()
                       ^~~~~~~~~~~
src/validation/honest_validation_framework.py:176: error: Argument 1 to
"detect_regime" of "RegimeClassifier" has incompatible type "DataFrame";
expected "Mapping[str, object]"  [arg-type]
    ...ional[RegimeResult] = await self.regime_classifier.detect_regime(data)
                                                                        ^~~~
src/validation/honest_validation_framework.py:216: error: Unused "type: ignore"
comment  [unused-ignore]
                test_genome = DecisionGenome()  # type: ignore[call-arg]
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/validation/honest_validation_framework.py:216: error: Cannot instantiate
protocol class "DecisionGenome"  [misc]
                test_genome = DecisionGenome()  # type: ignore[call-arg]
                              ^~~~~~~~~~~~~~~~
src/validation/honest_validation_framework.py:216: note: Error code "misc" not covered by "type: ignore" comment
src/validation/honest_validation_framework.py:236: error: Unused "type: ignore"
comment  [unused-ignore]
                    success = bool(self.strategy_manager.add_strategy(test...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/validation/honest_validation_framework.py:277: error: Unused "type: ignore"
comment  [unused-ignore]
                    signals = self.strategy_manager.evaluate_strategies("E...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/validation/honest_validation_framework.py:325: error: Unused "type: ignore"
comment  [unused-ignore]
                    async_df = await self.market_data.get_market_data("EUR...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/validation/honest_validation_framework.py:436: error: Function is missing a
return type annotation  [no-untyped-def]
        def print_report(self, report: Dict[str, Any]):
        ^
src/validation/honest_validation_framework.py:461: error: Function is missing a
return type annotation  [no-untyped-def]
    async def main():
    ^
src/validation/honest_validation_framework.py:461: note: Use "-> None" if function does not return a value
src/trading/monitoring/performance_tracker.py:74: error: Missing type
parameters for generic type "Dict"  [type-arg]
            self.positions_history: List[Dict] = []
                                         ^
src/trading/monitoring/performance_tracker.py:75: error: Missing type
parameters for generic type "Dict"  [type-arg]
            self.trades_history: List[Dict] = []
                                      ^
src/trading/monitoring/performance_tracker.py:76: error: Missing type
parameters for generic type "Dict"  [type-arg]
            self.daily_equity: List[Dict] = []
                                    ^
src/trading/monitoring/performance_tracker.py:77: error: Missing type
parameters for generic type "Dict"  [type-arg]
            self.strategy_performance: Dict[str, Dict] = {}
                                                 ^
src/trading/monitoring/performance_tracker.py:78: error: Missing type
parameters for generic type "Dict"  [type-arg]
            self.regime_performance: Dict[str, Dict] = {}
                                               ^
src/trading/monitoring/performance_tracker.py:86: error: Missing type
parameters for generic type "Dict"  [type-arg]
        def update_position(self, position_data: Dict) -> None:
                                                 ^
src/trading/monitoring/performance_tracker.py:97: error: Missing type
parameters for generic type "Dict"  [type-arg]
        def record_trade(self, trade_data: Dict) -> None:
                                           ^
src/trading/monitoring/performance_tracker.py:202: error: Incompatible types in
assignment (expression has type "PerformanceMetrics", variable has type "None") 
[assignment]
            self.metrics = PerformanceMetrics(
                           ^
src/trading/monitoring/performance_tracker.py:212: error: Argument
"total_trades" to "PerformanceMetrics" has incompatible type "object"; expected
"int"  [arg-type]
                total_trades=trading_metrics["total_trades"],
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/monitoring/performance_tracker.py:213: error: Argument
"winning_trades" to "PerformanceMetrics" has incompatible type "object";
expected "int"  [arg-type]
                winning_trades=trading_metrics["winning_trades"],
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/monitoring/performance_tracker.py:214: error: Argument
"losing_trades" to "PerformanceMetrics" has incompatible type "object"; expected
"int"  [arg-type]
                losing_trades=trading_metrics["losing_trades"],
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/monitoring/performance_tracker.py:215: error: Argument "win_rate"
to "PerformanceMetrics" has incompatible type "object"; expected "float" 
[arg-type]
                win_rate=trading_metrics["win_rate"],
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/monitoring/performance_tracker.py:216: error: Argument "avg_win" to
"PerformanceMetrics" has incompatible type "object"; expected "float" 
[arg-type]
                avg_win=trading_metrics["avg_win"],
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/monitoring/performance_tracker.py:217: error: Argument "avg_loss"
to "PerformanceMetrics" has incompatible type "object"; expected "float" 
[arg-type]
                avg_loss=trading_metrics["avg_loss"],
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/monitoring/performance_tracker.py:218: error: Argument
"profit_factor" to "PerformanceMetrics" has incompatible type "object"; expected
"float"  [arg-type]
                profit_factor=trading_metrics["profit_factor"],
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/monitoring/performance_tracker.py:219: error: Argument
"avg_trade_duration" to "PerformanceMetrics" has incompatible type "object";
expected "float"  [arg-type]
                avg_trade_duration=trading_metrics["avg_trade_duration"],
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/monitoring/performance_tracker.py:228: error: Incompatible types in
assignment (expression has type "datetime", variable has type "None") 
[assignment]
            self.last_calculation = datetime.now()
                                    ^~~~~~~~~~~~~~
src/trading/monitoring/performance_tracker.py:233: error: Incompatible return
value type (got "None", expected "PerformanceMetrics")  [return-value]
            return self.metrics
                   ^~~~~~~~~~~~
src/trading/monitoring/performance_tracker.py:273: error: Returning Any from
function declared to return "float"  [no-any-return]
            return (1 + total_return) ** (365 / total_days) - 1
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/monitoring/performance_tracker.py:284: error: Returning Any from
function declared to return "float"  [no-any-return]
            return returns_array.mean() / returns_array.std() * np.sqrt(25...
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/monitoring/performance_tracker.py:301: error: Returning Any from
function declared to return "float"  [no-any-return]
            return returns_array.mean() / downside_deviation * np.sqrt(252...
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/monitoring/performance_tracker.py:310: error: Returning Any from
function declared to return "float"  [no-any-return]
            return abs(drawdown.min())
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/monitoring/performance_tracker.py:358: error: "float" has no
attribute "total_seconds"  [attr-defined]
                avg_trade_duration = trades_df["duration"].mean().total_se...
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/trading/monitoring/performance_tracker.py:594: error: Unsupported operand
types for > ("float" and "object")  [operator]
                    if perf["win_rate"] < 0.3:
                       ^
src/thinking/prediction/predictive_modeler.py:43: error: Argument 1 to
"PredictiveMarketModeler" has incompatible type "str"; expected "StateStore" 
[arg-type]
                modeler = PredictiveMarketModeler(model_run_id)
                                                  ^~~~~~~~~~~~
src/thinking/prediction/predictive_modeler.py:57: error:
"PredictiveMarketModeler" has no attribute "forecast"  [attr-defined]
                forecast = await modeler.forecast(sample_data)
                                 ^~~~~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:56: error: "object" has no
attribute "iloc"  [attr-defined]
                        "final_capital": performance_data['equity_curve']....
                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/thinking/analysis/performance_analyzer.py:56: error: Argument 1 to "len"
has incompatible type "object"; expected "Sized"  [arg-type]
    ...performance_data['equity_curve'].iloc[-1] if len(performance_data['equ...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
src/thinking/analysis/performance_analyzer.py:96: error: Argument 1 to "len"
has incompatible type "object"; expected "Sized"  [arg-type]
                for i in range(1, len(equity_curve)):
                                      ^~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:97: error: Value of type "object"
is not indexable  [index]
                    if equity_curve[i-1] > 0:
                       ^~~~~~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:98: error: Value of type "object"
is not indexable  [index]
                        returns.append((equity_curve[i] - equity_curve[i-1...
                                        ^~~~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:101: error: Argument 2 to
"_calculate_metrics_from_returns" of "PerformanceAnalyzer" has incompatible type
"object"; expected "list[float]"  [arg-type]
    ... = self._calculate_metrics_from_returns(returns, equity_curve, trades)
                                                        ^~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:101: error: Argument 3 to
"_calculate_metrics_from_returns" of "PerformanceAnalyzer" has incompatible type
"object"; expected "list[dict[str, object]]"  [arg-type]
    ... = self._calculate_metrics_from_returns(returns, equity_curve, trades)
                                                                      ^~~~~~
src/thinking/analysis/performance_analyzer.py:112: error: Argument 1 to "len"
has incompatible type "object"; expected "Sized"  [arg-type]
                        "trade_count": len(trades),
                                           ^~~~~~
src/thinking/analysis/performance_analyzer.py:113: error: Argument 1 to "len"
has incompatible type "object"; expected "Sized"  [arg-type]
                        "equity_curve_length": len(equity_curve),
                                                   ^~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:114: error: Value of type
"object" is not indexable  [index]
                        "initial_capital": equity_curve[0] if equity_curve...
                                           ^~~~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:115: error: Value of type
"object" is not indexable  [index]
                        "final_capital": equity_curve[-1] if equity_curve ...
                                         ^~~~~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:163: error: Argument 1 to
"_calculate_max_drawdown" of "PerformanceAnalyzer" has incompatible type
"list[float]"; expected "Series[Any]"  [arg-type]
            max_drawdown = self._calculate_max_drawdown(equity_curve)
                                                        ^~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:167: error: Unsupported operand
types for < ("int" and "object")  [operator]
    ...           winning_trades = [t for t in trades if t.get("pnl", 0) > 0]
                                                         ^
src/thinking/analysis/performance_analyzer.py:168: error: Unsupported operand
types for > ("int" and "object")  [operator]
                losing_trades = [t for t in trades if t.get("pnl", 0) < 0]
                                                      ^
src/thinking/analysis/performance_analyzer.py:172: error: Generator has
incompatible item type "object"; expected "bool"  [misc]
                total_wins = sum(t.get("pnl", 0) for t in winning_trades)
                                 ^~~~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:173: error: Generator has
incompatible item type "object"; expected "bool"  [misc]
                total_losses = abs(sum(t.get("pnl", 0) for t in losing_tra...
                                       ^~~~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:258: error: Unsupported left
operand type for - ("object")  [operator]
            total_return = (final_capital - initial_capital) / initial_cap...
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:258: error: Unsupported operand
types for < ("int" and "object")  [operator]
    ..._capital - initial_capital) / initial_capital if initial_capital > 0 e...
                                                        ^
src/thinking/analysis/performance_analyzer.py:261: error: Argument 1 to "len"
has incompatible type "object"; expected "Sized"  [arg-type]
            if len(equity_curve) > 1:
                   ^~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:262: error: "object" has no
attribute "index"  [attr-defined]
                days = (equity_curve.index[-1] - equity_curve.index[0]).da...
                        ^~~~~~~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:264: error: Unsupported left
operand type for / ("object")  [operator]
                    annualized_return = ((final_capital / initial_capital)...
                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:271: error: "object" has no
attribute "std"  [attr-defined]
            volatility = returns.std() * np.sqrt(self.trading_days_per_yea...
                         ^~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:271: error: Argument 1 to "len"
has incompatible type "object"; expected "Sized"  [arg-type]
    ...std() * np.sqrt(self.trading_days_per_year) if len(returns) > 1 else 0
                                                          ^~~~~~~
src/thinking/analysis/performance_analyzer.py:281: error: Argument 1 to "len"
has incompatible type "object"; expected "Sized"  [arg-type]
            if len(returns) > 1:
                   ^~~~~~~
src/thinking/analysis/performance_analyzer.py:282: error: Value of type
"object" is not indexable  [index]
                negative_returns = returns[returns < 0]
                                   ^~~~~~~~~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:282: error: Unsupported operand
types for > ("int" and "object")  [operator]
                negative_returns = returns[returns < 0]
                                           ^
src/thinking/analysis/performance_analyzer.py:292: error: Argument 1 to
"_calculate_max_drawdown" of "PerformanceAnalyzer" has incompatible type
"object"; expected "Series[Any]"  [arg-type]
            max_drawdown = self._calculate_max_drawdown(equity_curve)
                                                        ^~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:296: error: "object" has no
attribute "__iter__"; maybe "__dir__" or "__str__"? (not iterable) 
[attr-defined]
                winning_trades = [r for r in trade_returns if r > 0]
                                             ^~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:297: error: "object" has no
attribute "__iter__"; maybe "__dir__" or "__str__"? (not iterable) 
[attr-defined]
                losing_trades = [r for r in trade_returns if r < 0]
                                            ^~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:299: error: Argument 1 to "len"
has incompatible type "object"; expected "Sized"  [arg-type]
                win_rate = len(winning_trades) / len(trade_returns) if tra...
                                                     ^~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:310: error: Argument 1 to "len"
has incompatible type "object"; expected "Sized"  [arg-type]
            total_trades = len(trade_returns)
                               ^~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:326: error: Argument 1 to "len"
has incompatible type "object"; expected "Sized"  [arg-type]
                    "data_points": len(equity_curve)
                                       ^~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:368: error: Argument 1 to "len"
has incompatible type "object"; expected "Sized"  [arg-type]
            if len(performance_data['equity_curve']) < 2:
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:371: error: "object" has no
attribute "index"  [attr-defined]
            total_days = (performance_data['equity_curve'].index[-1] - per...
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:372: error: Argument 1 to "len"
has incompatible type "object"; expected "Sized"  [arg-type]
            trade_count = len(performance_data['trade_returns'])
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:384: error: Argument 1 to "len"
has incompatible type "object"; expected "Sized"  [arg-type]
            data_points = len(performance_data['equity_curve'])
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:395: error: Argument 1 to "len"
has incompatible type "object"; expected "Sized"  [arg-type]
            trade_count = len(performance_data['trade_returns'])
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:406: error: Argument 1 to "len"
has incompatible type "object"; expected "Sized"  [arg-type]
            if len(performance_data['equity_curve']) > 1:
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:407: error: "object" has no
attribute "index"  [attr-defined]
                time_span = (performance_data['equity_curve'].index[-1] - ...
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:419: error: Incompatible return
value type (got "floating[Any]", expected "float")  [return-value]
            return np.mean(confidence_factors)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:426: error: Argument 1 to "len"
has incompatible type "object"; expected "Sized"  [arg-type]
            equity_curve_length = len(backtest_results.get("equity_curve",...
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/thinking/analysis/performance_analyzer.py:437: error: Argument 1 to "len"
has incompatible type "object"; expected "Sized"  [arg-type]
            trade_count = len(backtest_results.get("trades", []))
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:447: error: Incompatible return
value type (got "floating[Any] | float", expected "float")  [return-value]
            return np.mean(confidence_factors) if confidence_factors else ...
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:502: error: Argument 1 to "mean"
has incompatible type "list[object]"; expected
"_SupportsArray[dtype[numpy.bool[builtins.bool] | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool] | integer[Any] | floating[Any]]]] | float | _NestedSequence[float]"
 [arg-type]
                'average_return': np.mean(returns),
                                          ^~~~~~~
src/thinking/analysis/performance_analyzer.py:503: error: Argument 1 to "std"
has incompatible type "list[object]"; expected
"_SupportsArray[dtype[numpy.bool[builtins.bool] | number[Any, int | float | complex]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool] | number[Any, int | float | complex]]]] | complex | _NestedSequence[complex]"
 [arg-type]
                'return_std': np.std(returns),
                                     ^~~~~~~
src/thinking/analysis/performance_analyzer.py:504: error: Argument 1 to "mean"
has incompatible type "list[object]"; expected
"_SupportsArray[dtype[numpy.bool[builtins.bool] | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool] | integer[Any] | floating[Any]]]] | float | _NestedSequence[float]"
 [arg-type]
                'average_sharpe': np.mean(sharpe_ratios),
                                          ^~~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:505: error: Argument 1 to "mean"
has incompatible type "list[object]"; expected
"_SupportsArray[dtype[numpy.bool[builtins.bool] | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool] | integer[Any] | floating[Any]]]] | float | _NestedSequence[float]"
 [arg-type]
                'average_drawdown': np.mean(drawdowns),
                                            ^~~~~~~~~
src/thinking/analysis/performance_analyzer.py:506: error: Argument 1 to "mean"
has incompatible type "list[object]"; expected
"_SupportsArray[dtype[numpy.bool[builtins.bool] | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool] | integer[Any] | floating[Any]]]] | float | _NestedSequence[float]"
 [arg-type]
                'average_confidence': np.mean(confidences),
                                              ^~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:507: error: Value of type
variable "SupportsRichComparisonT" of "max" cannot be "object"  [type-var]
                'best_return': max(returns) if returns else 0,
                               ^~~~~~~~~~~~
src/thinking/analysis/performance_analyzer.py:508: error: Value of type
variable "SupportsRichComparisonT" of "min" cannot be "object"  [type-var]
                'worst_return': min(returns) if returns else 0
                                ^~~~~~~~~~~~
src/sensory/organs/dimensions/why_organ.py:47: error: Incompatible types in
assignment (expression has type "None", variable has type "WhyConfig") 
[assignment]
                self.why_cfg = None
                               ^~~~
src/sensory/organs/dimensions/why_organ.py:60: error: Incompatible types in
assignment (expression has type "None", variable has type
"EconomicDataProvider")  [assignment]
                self.economic_provider = None
                                         ^~~~
src/sensory/organs/dimensions/why_organ.py:61: error: Incompatible types in
assignment (expression has type "None", variable has type "FundamentalAnalyzer")
 [assignment]
                self.fundamental_analyzer = None
                                            ^~~~
src/sensory/organs/dimensions/why_organ.py:139: error: Name "List" is not
defined  [name-defined]
            self, market_data: List[MarketData], symbol: str = "UNKNOWN"
                               ^~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/why_organ.py:139: note: Did you forget to import it from "typing"? (Suggestion: "from typing import List")
src/sensory/organs/dimensions/why_organ.py:239: error: Incompatible return
value type (got "dict[str, float | str]", expected "dict[str, object]") 
[return-value]
                return drivers
                       ^~~~~~~
src/sensory/organs/dimensions/why_organ.py:239: note: "dict" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance
src/sensory/organs/dimensions/why_organ.py:239: note: Consider using "Mapping" instead, which is covariant in the value type
src/sensory/organs/dimensions/why_organ.py:239: note: Perhaps you need a type annotation for "drivers"? Suggestion: "dict[str, object]"
src/sensory/organs/dimensions/why_organ.py:305: error: Incompatible return
value type (got "dict[str, float]", expected "dict[str, object]") 
[return-value]
                return self.fundamental_analyzer.analyze_economic_momentum...
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/sensory/organs/dimensions/why_organ.py:305: note: "dict" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance
src/sensory/organs/dimensions/why_organ.py:305: note: Consider using "Mapping" instead, which is covariant in the value type
src/sensory/organs/dimensions/why_organ.py:316: error: Incompatible return
value type (got "dict[str, float]", expected "dict[str, object]") 
[return-value]
                return self.fundamental_analyzer.analyze_risk_sentiment(df...
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/why_organ.py:316: note: "dict" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance
src/sensory/organs/dimensions/why_organ.py:316: note: Consider using "Mapping" instead, which is covariant in the value type
src/sensory/organs/dimensions/why_organ.py:327: error: Incompatible return
value type (got "dict[str, float]", expected "dict[str, object]") 
[return-value]
                return self.fundamental_analyzer.analyze_yield_differentia...
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/sensory/organs/dimensions/why_organ.py:327: note: "dict" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance
src/sensory/organs/dimensions/why_organ.py:327: note: Consider using "Mapping" instead, which is covariant in the value type
src/sensory/organs/dimensions/why_organ.py:377: error: "object" has no
attribute "get"  [attr-defined]
                    analysis.get("fundamental_analysis", {})
                    ^
src/sensory/organs/dimensions/why_organ.py:382: error: "object" has no
attribute "get"  [attr-defined]
                    analysis.get("fundamental_analysis", {})
                    ^
src/sensory/organs/dimensions/why_organ.py:386: error: "object" has no
attribute "get"  [attr-defined]
                sentiment_score = analysis.get("sentiment_analysis", {}).g...
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/why_organ.py:415: error: No overload variant of
"int" matches argument type "object"  [call-overload]
                    int(data_points_obj) if not isinstance(data_points_obj...
                    ^~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/why_organ.py:415: note: Possible overload variants:
src/sensory/organs/dimensions/why_organ.py:415: note:     def __new__(cls, str | Buffer | SupportsInt | SupportsIndex | SupportsTrunc = ..., /) -> int
src/sensory/organs/dimensions/why_organ.py:415: note:     def __new__(cls, str | bytes | bytearray, /, base: SupportsIndex) -> int
src/sensory/organs/dimensions/why_organ.py:446: error: "MarketData" has no
attribute "spread"  [attr-defined]
                        "spread": md.spread,
                                  ^~~~~~~~~
src/sensory/organs/dimensions/why_organ.py:447: error: "MarketData" has no
attribute "mid_price"  [attr-defined]
                        "mid_price": md.mid_price,
                                     ^~~~~~~~~~~~
src/sensory/organs/dimensions/when_organ.py:364: error: "MarketData" has no
attribute "spread"  [attr-defined]
                        "spread": md.spread,
                                  ^~~~~~~~~
src/sensory/organs/dimensions/when_organ.py:365: error: "MarketData" has no
attribute "mid_price"  [attr-defined]
                        "mid_price": md.mid_price,
                                     ^~~~~~~~~~~~
src/sensory/organs/dimensions/institutional_tracker.py:119: error: Argument 1
to "_determine_institutional_bias" of "InstitutionalFootprintHunter" has
incompatible type "object"; expected "list[OrderBlock]"  [arg-type]
                    order_blocks, fvgs, smart_flow
                    ^~~~~~~~~~~~
src/sensory/organs/dimensions/institutional_tracker.py:119: error: Argument 2
to "_determine_institutional_bias" of "InstitutionalFootprintHunter" has
incompatible type "object"; expected "list[FairValueGap]"  [arg-type]
                    order_blocks, fvgs, smart_flow
                                  ^~~~
src/sensory/organs/dimensions/institutional_tracker.py:119: error: Argument 3
to "_determine_institutional_bias" of "InstitutionalFootprintHunter" has
incompatible type "object"; expected "float"  [arg-type]
                    order_blocks, fvgs, smart_flow
                                        ^~~~~~~~~~
src/sensory/organs/dimensions/institutional_tracker.py:124: error: Argument 1
to "_calculate_footprint_confidence" of "InstitutionalFootprintHunter" has
incompatible type "object"; expected "list[OrderBlock]"  [arg-type]
                    order_blocks, fvgs, sweeps
                    ^~~~~~~~~~~~
src/sensory/organs/dimensions/institutional_tracker.py:124: error: Argument 2
to "_calculate_footprint_confidence" of "InstitutionalFootprintHunter" has
incompatible type "object"; expected "list[FairValueGap]"  [arg-type]
                    order_blocks, fvgs, sweeps
                                  ^~~~
src/sensory/organs/dimensions/institutional_tracker.py:124: error: Argument 3
to "_calculate_footprint_confidence" of "InstitutionalFootprintHunter" has
incompatible type "object"; expected "list[LiquiditySweep]"  [arg-type]
                    order_blocks, fvgs, sweeps
                                        ^~~~~~
src/sensory/organs/dimensions/institutional_tracker.py:128: error: Argument 1
to "_identify_key_levels" of "InstitutionalFootprintHunter" has incompatible
type "object"; expected "list[OrderBlock]"  [arg-type]
                key_levels = self._identify_key_levels(order_blocks, fvgs)
                                                       ^~~~~~~~~~~~
src/sensory/organs/dimensions/institutional_tracker.py:128: error: Argument 2
to "_identify_key_levels" of "InstitutionalFootprintHunter" has incompatible
type "object"; expected "list[FairValueGap]"  [arg-type]
                key_levels = self._identify_key_levels(order_blocks, fvgs)
                                                                     ^~~~
src/sensory/organs/dimensions/institutional_tracker.py:131: error: Argument 2
to "_determine_market_structure" of "InstitutionalFootprintHunter" has
incompatible type "object"; expected "list[OrderBlock]"  [arg-type]
    ... market_structure = self._determine_market_structure(df, order_blocks)
                                                                ^~~~~~~~~~~~
src/sensory/organs/dimensions/institutional_tracker.py:134: error: Argument
"order_blocks" to "InstitutionalFootprint" has incompatible type "object";
expected "list[OrderBlock]"  [arg-type]
                    order_blocks=order_blocks,
                                 ^~~~~~~~~~~~
src/sensory/organs/dimensions/institutional_tracker.py:135: error: Argument
"fair_value_gaps" to "InstitutionalFootprint" has incompatible type "object";
expected "list[FairValueGap]"  [arg-type]
                    fair_value_gaps=fvgs,
                                    ^~~~
src/sensory/organs/dimensions/institutional_tracker.py:136: error: Argument
"liquidity_sweeps" to "InstitutionalFootprint" has incompatible type "object";
expected "list[LiquiditySweep]"  [arg-type]
                    liquidity_sweeps=sweeps,
                                     ^~~~~~
src/sensory/organs/dimensions/institutional_tracker.py:137: error: Argument
"smart_money_flow" to "InstitutionalFootprint" has incompatible type "object";
expected "float"  [arg-type]
                    smart_money_flow=smart_flow,
                                     ^~~~~~~~~~
src/sensory/organs/dimensions/institutional_tracker.py:161: error: "MarketData"
has no attribute "spread"  [attr-defined]
                    'spread': md.spread,
                              ^~~~~~~~~
src/sensory/organs/dimensions/institutional_tracker.py:162: error: "MarketData"
has no attribute "mid_price"  [attr-defined]
                    'mid_price': md.mid_price
                                 ^~~~~~~~~~~~
src/sensory/organs/dimensions/institutional_tracker.py:179: error: Unsupported
operand types for > ("Series[type[object]]" and "int")  [operator]
            gain = (delta.where(delta > 0, 0)).rolling(window=period).mean...
                                        ^
src/sensory/organs/dimensions/institutional_tracker.py:180: error: Unsupported
operand types for < ("Series[type[object]]" and "int")  [operator]
            loss = (-delta.where(delta < 0, 0)).rolling(window=period).mea...
                                         ^
src/sensory/organs/dimensions/institutional_tracker.py:301: error: Need type
annotation for "order_blocks" (hint: "order_blocks: list[<type>] = ...") 
[var-annotated]
            order_blocks = []
            ^~~~~~~~~~~~
src/sensory/organs/dimensions/institutional_tracker.py:364: error: Need type
annotation for "fvgs" (hint: "fvgs: list[<type>] = ...")  [var-annotated]
            fvgs = []
            ^~~~
src/sensory/organs/dimensions/institutional_tracker.py:418: error: Function is
missing a type annotation for one or more arguments  [no-untyped-def]
        def _calculate_fvg_strength(self, c1, c2, c3) -> float:
        ^
src/sensory/organs/dimensions/institutional_tracker.py:430: error: Returning
Any from function declared to return "float"  [no-any-return]
                return min(imbalance / avg_range, 1.0)
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/institutional_tracker.py:435: error: Function is
missing a type annotation for one or more arguments  [no-untyped-def]
        def _calculate_fill_probability(self, c1, c3) -> float:
        ^
src/sensory/organs/dimensions/institutional_tracker.py:440: error: Returning
Any from function declared to return "float"  [no-any-return]
                return max(0.1, min(0.9, 1.0 - gap_size / c1['close']))
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/institutional_tracker.py:449: error: Need type
annotation for "sweeps" (hint: "sweeps: list[<type>] = ...")  [var-annotated]
            sweeps = []
            ^~~~~~
src/sensory/organs/dimensions/institutional_tracker.py:463: error: Argument 1
to "_find_equal_levels" of "LiquidityAnalyzer" has incompatible type
"ExtensionArray | ndarray[tuple[Any, ...], dtype[Any]]"; expected
"ndarray[tuple[Any, ...], dtype[Any]]"  [arg-type]
    ...           equal_highs = self._find_equal_levels(recent_highs, toleran...
                                                        ^~~~~~~~~~~~
src/sensory/organs/dimensions/institutional_tracker.py:480: error: Argument 1
to "_find_equal_levels" of "LiquidityAnalyzer" has incompatible type
"ExtensionArray | ndarray[tuple[Any, ...], dtype[Any]]"; expected
"ndarray[tuple[Any, ...], dtype[Any]]"  [arg-type]
    ...            equal_lows = self._find_equal_levels(recent_lows, toleranc...
                                                        ^~~~~~~~~~~
src/sensory/organs/dimensions/institutional_tracker.py:535: error: Returning
Any from function declared to return "float"  [no-any-return]
                return max(-1.0, min(1.0, (flow_ratio - 1) / (flow_ratio +...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/sensory/organs/dimensions/institutional_tracker.py:545: error: Function is
missing a return type annotation  [no-untyped-def]
        def __init__(self):
        ^
src/sensory/organs/dimensions/institutional_tracker.py:545: note: Use "-> None" if function does not return a value
src/sensory/organs/dimensions/institutional_tracker.py:598: error: Returning
Any from function declared to return "MarketRegime"  [no-any-return]
                return MarketRegime.BULLISH
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/institutional_tracker.py:598: error:
"type[MarketRegime]" has no attribute "BULLISH"  [attr-defined]
                return MarketRegime.BULLISH
                       ^~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/institutional_tracker.py:600: error: Returning
Any from function declared to return "MarketRegime"  [no-any-return]
                return MarketRegime.BEARISH
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/institutional_tracker.py:600: error:
"type[MarketRegime]" has no attribute "BEARISH"  [attr-defined]
                return MarketRegime.BEARISH
                       ^~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/institutional_tracker.py:602: error: Returning
Any from function declared to return "MarketRegime"  [no-any-return]
                return MarketRegime.RANGING
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/institutional_tracker.py:602: error:
"type[MarketRegime]" has no attribute "RANGING"  [attr-defined]
                return MarketRegime.RANGING
                       ^~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/institutional_tracker.py:606: error: Function is
missing a return type annotation  [no-untyped-def]
        async def test_footprint_hunter():
        ^
src/sensory/organs/dimensions/institutional_tracker.py:606: note: Use "-> None" if function does not return a value
src/sensory/organs/dimensions/how_organ.py:297: error: "MarketData" has no
attribute "spread"  [attr-defined]
                        "spread": md.spread,
                                  ^~~~~~~~~
src/sensory/organs/dimensions/how_organ.py:298: error: "MarketData" has no
attribute "mid_price"  [attr-defined]
                        "mid_price": md.mid_price,
                                     ^~~~~~~~~~~~
src/sensory/organs/dimensions/chaos_adaptation.py:70: error: Function is
missing a return type annotation  [no-untyped-def]
        def __init__(self):
        ^
src/sensory/organs/dimensions/chaos_adaptation.py:70: note: Use "-> None" if function does not return a value
src/sensory/organs/dimensions/chaos_adaptation.py:150: error: Returning Any
from function declared to return "float"  [no-any-return]
            return min(max(np.mean(factors), 0.0), 1.0)
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/chaos_adaptation.py:150: error: No overload
variant of "max" matches argument types "floating[Any]", "float" 
[call-overload]
            return min(max(np.mean(factors), 0.0), 1.0)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/chaos_adaptation.py:150: note: Possible overload variants:
src/sensory/organs/dimensions/chaos_adaptation.py:150: note:     def [SupportsRichComparisonT: SupportsDunderLT[Any] | SupportsDunderGT[Any]] max(SupportsRichComparisonT, SupportsRichComparisonT, /, *_args: SupportsRichComparisonT, key: None = ...) -> SupportsRichComparisonT
src/sensory/organs/dimensions/chaos_adaptation.py:150: note:     def [_T] max(_T, _T, /, *_args: _T, key: Callable[[_T], SupportsDunderLT[Any] | SupportsDunderGT[Any]]) -> _T
src/sensory/organs/dimensions/chaos_adaptation.py:150: note:     def [SupportsRichComparisonT: SupportsDunderLT[Any] | SupportsDunderGT[Any]] max(Iterable[SupportsRichComparisonT], /, *, key: None = ...) -> SupportsRichComparisonT
src/sensory/organs/dimensions/chaos_adaptation.py:150: note:     def [_T] max(Iterable[_T], /, *, key: Callable[[_T], SupportsDunderLT[Any] | SupportsDunderGT[Any]]) -> _T
src/sensory/organs/dimensions/chaos_adaptation.py:150: note:     def [SupportsRichComparisonT: SupportsDunderLT[Any] | SupportsDunderGT[Any], _T] max(Iterable[SupportsRichComparisonT], /, *, key: None = ..., default: _T) -> SupportsRichComparisonT | _T
src/sensory/organs/dimensions/chaos_adaptation.py:150: note:     def [_T1, _T2] max(Iterable[_T1], /, *, key: Callable[[_T1], SupportsDunderLT[Any] | SupportsDunderGT[Any]], default: _T2) -> _T1 | _T2
src/sensory/organs/dimensions/chaos_adaptation.py:161: error: Returning Any
from function declared to return "float"  [no-any-return]
            return min(max(np.mean(confidences), 0.0), 1.0)
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/chaos_adaptation.py:161: error: No overload
variant of "max" matches argument types "floating[Any]", "float" 
[call-overload]
            return min(max(np.mean(confidences), 0.0), 1.0)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/chaos_adaptation.py:161: note: Possible overload variants:
src/sensory/organs/dimensions/chaos_adaptation.py:161: note:     def [SupportsRichComparisonT: SupportsDunderLT[Any] | SupportsDunderGT[Any]] max(SupportsRichComparisonT, SupportsRichComparisonT, /, *_args: SupportsRichComparisonT, key: None = ...) -> SupportsRichComparisonT
src/sensory/organs/dimensions/chaos_adaptation.py:161: note:     def [_T] max(_T, _T, /, *_args: _T, key: Callable[[_T], SupportsDunderLT[Any] | SupportsDunderGT[Any]]) -> _T
src/sensory/organs/dimensions/chaos_adaptation.py:161: note:     def [SupportsRichComparisonT: SupportsDunderLT[Any] | SupportsDunderGT[Any]] max(Iterable[SupportsRichComparisonT], /, *, key: None = ...) -> SupportsRichComparisonT
src/sensory/organs/dimensions/chaos_adaptation.py:161: note:     def [_T] max(Iterable[_T], /, *, key: Callable[[_T], SupportsDunderLT[Any] | SupportsDunderGT[Any]]) -> _T
src/sensory/organs/dimensions/chaos_adaptation.py:161: note:     def [SupportsRichComparisonT: SupportsDunderLT[Any] | SupportsDunderGT[Any], _T] max(Iterable[SupportsRichComparisonT], /, *, key: None = ..., default: _T) -> SupportsRichComparisonT | _T
src/sensory/organs/dimensions/chaos_adaptation.py:161: note:     def [_T1, _T2] max(Iterable[_T1], /, *, key: Callable[[_T1], SupportsDunderLT[Any] | SupportsDunderGT[Any]], default: _T2) -> _T1 | _T2
src/sensory/organs/dimensions/chaos_adaptation.py:265: error: Returning Any
from function declared to return "float"  [no-any-return]
            return (data['close'].iloc[-1] - data['close'].iloc[0]) / data...
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/sensory/organs/dimensions/chaos_adaptation.py:360: error: Returning Any
from function declared to return "float"  [no-any-return]
            return (data['close'].iloc[-1] - data['close'].iloc[0]) / data...
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/sensory/organs/dimensions/chaos_adaptation.py:415: error: Returning Any
from function declared to return "float"  [no-any-return]
            return (prices.iloc[-1] - prices.iloc[0]) / prices.iloc[0]
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/anomaly_dimension.py:93: error: Argument 1 to
"zscore" has incompatible type
"ExtensionArray | ndarray[tuple[Any, ...], dtype[Any]]"; expected
"CanArray[tuple[Any, ...], dtype[integer[Any] | numpy.bool[builtins.bool]]]" 
[arg-type]
            z_scores = np.abs(stats.zscore(prices))
                                           ^~~~~~
src/sensory/organs/dimensions/anomaly_dimension.py:93: error: Argument 1 to
"zscore" has incompatible type
"ExtensionArray | ndarray[tuple[Any, ...], dtype[Any]]"; expected
"CanArray[Any, dtype[integer[Any] | numpy.bool[builtins.bool]]]"  [arg-type]
            z_scores = np.abs(stats.zscore(prices))
                                           ^~~~~~
src/sensory/organs/dimensions/anomaly_dimension.py:121: error: Argument 1 to
"mean" has incompatible type
"ExtensionArray | ndarray[tuple[Any, ...], dtype[Any]]"; expected
"_SupportsArray[dtype[numpy.bool[builtins.bool] | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool] | integer[Any] | floating[Any]]]] | float | _NestedSequence[float]"
 [arg-type]
            mean_volume = np.mean(volumes)
                                  ^~~~~~~
src/sensory/organs/dimensions/anomaly_dimension.py:122: error: Argument 1 to
"std" has incompatible type
"ExtensionArray | ndarray[tuple[Any, ...], dtype[Any]]"; expected
"_SupportsArray[dtype[numpy.bool[builtins.bool] | number[Any, int | float | complex]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool] | number[Any, int | float | complex]]]] | complex | _NestedSequence[complex]"
 [arg-type]
            std_volume = np.std(volumes)
                                ^~~~~~~
src/sensory/organs/analyzers/anomaly_organ.py:273: error: Need type annotation
for "anomalies" (hint: "anomalies: list[<type>] = ...")  [var-annotated]
                anomalies = []
                ^~~~~~~~~
src/sensory/organs/analyzers/anomaly_organ.py:307: error: Incompatible return
value type (got "list[dict[str, float | int | str | Any | None]]", expected
"list[AnomalyRecord]")  [return-value]
                return anomalies
                       ^~~~~~~~~
src/sensory/organs/analyzers/anomaly_organ.py:316: error: Need type annotation
for "anomalies" (hint: "anomalies: list[<type>] = ...")  [var-annotated]
                anomalies = []
                ^~~~~~~~~
src/sensory/organs/analyzers/anomaly_organ.py:351: error: Incompatible return
value type (got "list[dict[str, float | int | str | Any | None]]", expected
"list[AnomalyRecord]")  [return-value]
                return anomalies
                       ^~~~~~~~~
src/sensory/organs/analyzers/anomaly_organ.py:460: error: Need type annotation
for "patterns" (hint: "patterns: list[<type>] = ...")  [var-annotated]
                patterns = []
                ^~~~~~~~
src/sensory/organs/analyzers/anomaly_organ.py:480: error: Incompatible return
value type (got "list[dict[str, object]]", expected "list[ChaosPattern]") 
[return-value]
                return patterns
                       ^~~~~~~~
src/sensory/organs/analyzers/anomaly_organ.py:489: error: Need type annotation
for "patterns" (hint: "patterns: list[<type>] = ...")  [var-annotated]
                patterns = []
                ^~~~~~~~
src/sensory/organs/analyzers/anomaly_organ.py:508: error: Incompatible return
value type (got "list[dict[str, object]]", expected "list[ChaosPattern]") 
[return-value]
                return patterns
                       ^~~~~~~~
src/sensory/organs/analyzers/anomaly_organ.py:517: error: Need type annotation
for "patterns" (hint: "patterns: list[<type>] = ...")  [var-annotated]
                patterns = []
                ^~~~~~~~
src/sensory/organs/analyzers/anomaly_organ.py:537: error: Incompatible return
value type (got "list[dict[str, object]]", expected "list[ChaosPattern]") 
[return-value]
                return patterns
                       ^~~~~~~~
src/sensory/organs/analyzers/anomaly_organ.py:585: error: Returning Any from
function declared to return "float"  [no-any-return]
                return min(max(normalized_entropy, 0.0), 1.0)
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/analyzers/anomaly_organ.py:700: error: Need type annotation
for "patterns" (hint: "patterns: list[<type>] = ...")  [var-annotated]
                patterns = []
                ^~~~~~~~
src/sensory/organs/analyzers/anomaly_organ.py:727: error: Incompatible return
value type (got "list[dict[str, object]]", expected "list[ManipulationPattern]")
 [return-value]
                return patterns
                       ^~~~~~~~
src/sensory/organs/analyzers/anomaly_organ.py:736: error: Need type annotation
for "patterns" (hint: "patterns: list[<type>] = ...")  [var-annotated]
                patterns = []
                ^~~~~~~~
src/sensory/organs/analyzers/anomaly_organ.py:762: error: Incompatible return
value type (got "list[dict[str, object]]", expected "list[ManipulationPattern]")
 [return-value]
                return patterns
                       ^~~~~~~~
src/sensory/organs/analyzers/anomaly_organ.py:771: error: Need type annotation
for "patterns" (hint: "patterns: list[<type>] = ...")  [var-annotated]
                patterns = []
                ^~~~~~~~
src/sensory/organs/analyzers/anomaly_organ.py:803: error: Incompatible return
value type (got "list[dict[str, object]]", expected "list[ManipulationPattern]")
 [return-value]
                return patterns
                       ^~~~~~~~
src/orchestration/compose.py:139: error: Unused "type: ignore" comment 
[unused-ignore]
                return await asyncio.to_thread(func, data)  # type: ignore...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/orchestration/compose.py:275: error: Unused "type: ignore" comment 
[unused-ignore]
                            d[key] = getattr(res, key)  # type: ignore[att...
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/orchestration/compose.py:328: error: Unused "type: ignore" comment 
[unused-ignore]
                            candidate = from_env() if callable(from_env) e...
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/orchestration/compose.py:351: error: Unused "type: ignore" comment 
[unused-ignore]
                        val = obj[key]  # type: ignore[index]
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/orchestration/compose.py:376: error: Unused "type: ignore" comment 
[unused-ignore]
                        ns_val = obj[namespace]  # type: ignore[index]
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/data_foundation/persist/parquet_writer.py:10: error: Incompatible types in
assignment (expression has type "None", variable has type Module)  [assignment]
        pd = None
             ^~~~
src/validation/phase2c_validation_suite.py:27: error: Function is missing a
return type annotation  [no-untyped-def]
        def __init__(self):
        ^
src/validation/phase2c_validation_suite.py:27: note: Use "-> None" if function does not return a value
src/validation/phase2c_validation_suite.py:84: error: "Sequence[str]" has no
attribute "append"  [attr-defined]
            accuracy_results['tests'].append(anomaly_result.to_dict())
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/validation/phase2c_validation_suite.py:88: error: "Sequence[str]" has no
attribute "append"  [attr-defined]
            accuracy_results['tests'].append(regime_result.to_dict())
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/validation/phase2c_validation_suite.py:92: error: "Sequence[str]" has no
attribute "append"  [attr-defined]
            accuracy_results['tests'].append(performance_result.to_dict())
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/validation/phase2c_validation_suite.py:95: error: Generator has
incompatible item type "int"; expected "bool"  [misc]
            passed = sum(1 for test in accuracy_results['tests'] if test['...
                         ^
src/validation/phase2c_validation_suite.py:95: error: Invalid index type "str"
for "str"; expected type "SupportsIndex | slice[Any, Any, Any]"  [index]
    ...assed = sum(1 for test in accuracy_results['tests'] if test['passed'])
                                                                   ^~~~~~~~
src/validation/phase2c_validation_suite.py:98: error: Incompatible types in
assignment (expression has type "dict[str, float | int | str]", target has type
"Sequence[str]")  [assignment]
            accuracy_results['summary'] = {
                                          ^
src/validation/phase2c_validation_suite.py:149: error: Function is missing a
return type annotation  [no-untyped-def]
        def print_comprehensive_report(self, report: Dict[str, Any]):
        ^
src/validation/phase2c_validation_suite.py:180: error: Function is missing a
return type annotation  [no-untyped-def]
    async def main():
    ^
src/validation/phase2c_validation_suite.py:180: note: Use "-> None" if function does not return a value
src/trading/portfolio/real_portfolio_monitor.py:12: error: Module
"src.trading.models" has no attribute "PortfolioSnapshot"  [attr-defined]
    from ..models import PortfolioSnapshot, Position
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/portfolio/real_portfolio_monitor.py:104: error: Unexpected keyword
argument "status" for "Position"  [call-arg]
                    position = Position(
                               ^
src/trading/models/position.py:48: note: "Position" defined here
src/trading/portfolio/real_portfolio_monitor.py:104: error: Unexpected keyword
argument "stop_loss" for "Position"  [call-arg]
                    position = Position(
                               ^
src/trading/portfolio/real_portfolio_monitor.py:104: error: Unexpected keyword
argument "take_profit" for "Position"  [call-arg]
                    position = Position(
                               ^
src/trading/portfolio/real_portfolio_monitor.py:104: error: Unexpected keyword
argument "entry_time" for "Position"; did you mean "entry_price"?  [call-arg]
                    position = Position(
                               ^
src/trading/portfolio/real_portfolio_monitor.py:104: error: Unexpected keyword
argument "exit_time" for "Position"  [call-arg]
                    position = Position(
                               ^
src/trading/portfolio/real_portfolio_monitor.py:150: error: "Position" has no
attribute "status"  [attr-defined]
                    position.status.value,
                    ^~~~~~~~~~~~~~~
src/trading/portfolio/real_portfolio_monitor.py:151: error: "Position" has no
attribute "stop_loss"  [attr-defined]
                    position.stop_loss,
                    ^~~~~~~~~~~~~~~~~~
src/trading/portfolio/real_portfolio_monitor.py:152: error: "Position" has no
attribute "take_profit"  [attr-defined]
                    position.take_profit,
                    ^~~~~~~~~~~~~~~~~~~~
src/trading/portfolio/real_portfolio_monitor.py:153: error: "Position" has no
attribute "entry_time"; maybe "entry_price"?  [attr-defined]
                    position.entry_time.isoformat(),
                    ^~~~~~~~~~~~~~~~~~~
src/trading/portfolio/real_portfolio_monitor.py:162: error: Invalid index type
"str | int | None" for "dict[str, Position]"; expected type "str"  [index]
                self._position_cache[position.position_id] = position
                                     ^~~~~~~~~~~~~~~~~~~~
src/trading/portfolio/real_portfolio_monitor.py:251: error: "Position" has no
attribute "close"  [attr-defined]
                    self._position_cache[position_id].close(exit_price, ex...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/trading/portfolio/real_portfolio_monitor.py:334: error: Missing positional
arguments "daily_returns", "volatility", "sortino_ratio", "var_95", "cvar_95",
"avg_win", "avg_loss", "avg_trade_duration", "strategy_performance",
"regime_performance", "correlation_matrix", "start_date", "end_date",
"last_updated" in call to "PerformanceMetrics"  [call-arg]
                    return PerformanceMetrics(
                           ^
src/trading/portfolio/real_portfolio_monitor.py:419: error: Missing positional
arguments "daily_returns", "volatility", "sortino_ratio", "var_95", "cvar_95",
"avg_win", "avg_loss", "avg_trade_duration", "strategy_performance",
"regime_performance", "correlation_matrix", "start_date", "end_date",
"last_updated" in call to "PerformanceMetrics"  [call-arg]
                return PerformanceMetrics(
                       ^
src/trading/portfolio/real_portfolio_monitor.py:433: error: Missing positional
arguments "daily_returns", "volatility", "sortino_ratio", "var_95", "cvar_95",
"avg_win", "avg_loss", "avg_trade_duration", "strategy_performance",
"regime_performance", "correlation_matrix", "start_date", "end_date",
"last_updated" in call to "PerformanceMetrics"  [call-arg]
                return PerformanceMetrics(
                       ^
src/trading/portfolio/real_portfolio_monitor.py:460: error: Unexpected keyword
argument "status" for "Position"  [call-arg]
                    position = Position(
                               ^
src/trading/portfolio/real_portfolio_monitor.py:460: error: Unexpected keyword
argument "stop_loss" for "Position"  [call-arg]
                    position = Position(
                               ^
src/trading/portfolio/real_portfolio_monitor.py:460: error: Unexpected keyword
argument "take_profit" for "Position"  [call-arg]
                    position = Position(
                               ^
src/trading/portfolio/real_portfolio_monitor.py:460: error: Unexpected keyword
argument "entry_time" for "Position"; did you mean "entry_price"?  [call-arg]
                    position = Position(
                               ^
src/trading/portfolio/real_portfolio_monitor.py:460: error: Unexpected keyword
argument "exit_time" for "Position"  [call-arg]
                    position = Position(
                               ^
src/thinking/thinking_manager.py:32: error: Need type annotation for
"market_data_buffer"  [var-annotated]
            self.market_data_buffer = deque(maxlen=100)  # Rolling buffer ...
                                      ^~~~~~~~~~~~~~~~~
src/thinking/thinking_manager.py:62: error: Missing named argument
"divergence_confidence" for "ContextPacket"  [call-arg]
            context = ContextPacket(
                      ^
src/thinking/thinking_manager.py:65: error: Argument 1 to "float" has
incompatible type "object"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
                current_price=float(market_data.get("close") or market_dat...
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/thinking/thinking_manager.py:66: error: Argument 1 to "float" has
incompatible type "object"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
                current_cvd=float(market_data.get("cvd") or market_data.ge...
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/thinking/thinking_manager.py:82: error: Argument "current_state" to
"predict_market_scenarios" of "PredictiveMarketModeler" has incompatible type
"dict[str, float]"; expected "dict[str, object]"  [arg-type]
                        current_state=current_state, time_horizon=timedelt...
                                      ^~~~~~~~~~~~~
src/thinking/thinking_manager.py:82: note: "dict" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance
src/thinking/thinking_manager.py:82: note: Consider using "Mapping" instead, which is covariant in the value type
src/thinking/analysis/market_analyzer.py:16: error: Module
"src.core.exceptions" has no attribute "ThinkingException"; maybe
"TradingException"?  [attr-defined]
    from src.core.exceptions import ThinkingException
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/analysis/market_analyzer.py:21: error: Cannot assign to a type 
[misc]
        ThinkingPattern = SensorySignal = AnalysisResult = object
        ^~~~~~~~~~~~~~~
src/thinking/analysis/market_analyzer.py:21: error: Incompatible types in
assignment (expression has type "type[object]", variable has type
"type[ThinkingPattern]")  [assignment]
        ThinkingPattern = SensorySignal = AnalysisResult = object
        ^
src/thinking/analysis/market_analyzer.py:21: error: Incompatible types in
assignment (expression has type "type[object]", variable has type
"type[SensorySignal]")  [assignment]
        ThinkingPattern = SensorySignal = AnalysisResult = object
        ^
src/thinking/analysis/market_analyzer.py:21: error: Incompatible types in
assignment (expression has type "type[object]", variable has type
"type[AnalysisResult]")  [assignment]
        ThinkingPattern = SensorySignal = AnalysisResult = object
                                                           ^~~~~~
src/thinking/analysis/market_analyzer.py:56: error: Extra keys ("timestamp",
"analysis_type", "result", "confidence", "metadata") for TypedDict
"AnalysisResult"  [typeddict-unknown-key]
                return AnalysisResult(
                       ^
src/thinking/analysis/market_analyzer.py:71: error: Argument 1 of "learn" is
incompatible with supertype "src.core.interfaces.ThinkingPattern"; supertype
defines the argument type as "Mapping[str, object]"  [override]
        def learn(self, feedback: dict[str, object]) -> bool:
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/analysis/market_analyzer.py:71: note: This violates the Liskov substitution principle
src/thinking/analysis/market_analyzer.py:71: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
src/thinking/analysis/market_analyzer.py:75: error: "PerformanceAnalyzer" has
no attribute "learn"  [attr-defined]
                performance_learned = self.performance_analyzer.learn(feed...
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/analysis/market_analyzer.py:76: error: "RiskAnalyzer" has no
attribute "learn"  [attr-defined]
                risk_learned = self.risk_analyzer.learn(feedback)
                               ^~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/analysis/market_analyzer.py:94: error: "AnalysisResult" has no
attribute "result"  [attr-defined]
            performance_metrics = performance_result.result.get("performan...
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/analysis/market_analyzer.py:95: error: "AnalysisResult" has no
attribute "result"  [attr-defined]
            risk_metrics = risk_result.result.get("risk_metrics", {})
                           ^~~~~~~~~~~~~~~~~~
src/thinking/analysis/market_analyzer.py:125: error: "SensorySignal" has no
attribute "signal_type"  [attr-defined]
                if signal.signal_type in ["sentiment", "momentum", "price_...
                   ^~~~~~~~~~~~~~~~~~
src/thinking/analysis/market_analyzer.py:126: error: "SensorySignal" has no
attribute "value"  [attr-defined]
                    sentiment_values.append(float(signal.value))  # ensure...
                                                  ^~~~~~~~~~~~
src/thinking/analysis/market_analyzer.py:127: error: "SensorySignal" has no
attribute "confidence"  [attr-defined]
                    confidences.append(float(signal.confidence))
                                             ^~~~~~~~~~~~~~~~~
src/thinking/analysis/market_analyzer.py:247: error: "SensorySignal" has no
attribute "confidence"  [attr-defined]
            confidences: list[float] = [float(s.confidence) for s in signa...
                                              ^~~~~~~~~~~~
src/sensory/organs/dimensions/pattern_engine.py:109: error: Function is missing
a return type annotation  [no-untyped-def]
        def __init__(self):
        ^
src/sensory/organs/dimensions/pattern_engine.py:109: note: Use "-> None" if function does not return a value
src/sensory/organs/dimensions/pattern_engine.py:215: error: Missing type
parameters for generic type "List"  [type-arg]
            self, fractals: List, harmonics: List, volume: VolumeProfile
                            ^
src/sensory/organs/dimensions/pattern_engine.py:329: error: Missing type
parameters for generic type "Dict"  [type-arg]
    ... _identify_significant_swings(self, data: pd.DataFrame) -> List[Dict]:
                                                                       ^
src/sensory/organs/dimensions/pattern_engine.py:333: error: Missing type
parameters for generic type "Dict"  [type-arg]
        def _calculate_fibonacci_levels(self, swing: Dict) -> List[float]:
                                                     ^
src/sensory/organs/dimensions/pattern_engine.py:337: error: Missing type
parameters for generic type "Dict"  [type-arg]
    ...f _identify_significant_moves(self, data: pd.DataFrame) -> List[Dict]:
                                                                       ^
src/sensory/organs/dimensions/pattern_engine.py:341: error: Missing type
parameters for generic type "Dict"  [type-arg]
        def _calculate_extension_levels(self, move: Dict) -> List[float]:
                                                    ^
src/sensory/organs/dimensions/pattern_engine.py:346: error: Missing type
parameters for generic type "List"  [type-arg]
            self, data: pd.DataFrame, highs: List, lows: List
                                             ^
src/sensory/organs/dimensions/pattern_engine.py:508: error: Missing type
parameters for generic type "Dict"  [type-arg]
        def _find_xabcd_patterns(self, data: pd.DataFrame) -> List[Dict]:
                                                                   ^
src/sensory/organs/dimensions/pattern_engine.py:552: error: Function is missing
a type annotation for one or more arguments  [no-untyped-def]
        def _calculate_harmonic_ratios(self, x, a, b, c, d) -> Dict[str, f...
        ^
src/sensory/organs/dimensions/pattern_engine.py:572: error: Missing type
parameters for generic type "Dict"  [type-arg]
        def _validate_gartley_ratios(self, pattern: Dict) -> bool:
                                                    ^
src/sensory/organs/dimensions/pattern_engine.py:577: error: Returning Any from
function declared to return "bool"  [no-any-return]
            return (
            ^
src/sensory/organs/dimensions/pattern_engine.py:584: error: Missing type
parameters for generic type "Dict"  [type-arg]
        def _validate_butterfly_ratios(self, pattern: Dict) -> bool:
                                                      ^
src/sensory/organs/dimensions/pattern_engine.py:589: error: Returning Any from
function declared to return "bool"  [no-any-return]
            return (
            ^
src/sensory/organs/dimensions/pattern_engine.py:596: error: Missing type
parameters for generic type "Dict"  [type-arg]
        def _validate_crab_ratios(self, pattern: Dict) -> bool:
                                                 ^
src/sensory/organs/dimensions/pattern_engine.py:601: error: Returning Any from
function declared to return "bool"  [no-any-return]
            return (
            ^
src/sensory/organs/dimensions/pattern_engine.py:608: error: Missing type
parameters for generic type "Dict"  [type-arg]
        def _validate_bat_ratios(self, pattern: Dict) -> bool:
                                                ^
src/sensory/organs/dimensions/pattern_engine.py:613: error: Returning Any from
function declared to return "bool"  [no-any-return]
            return (
            ^
src/sensory/organs/dimensions/pattern_engine.py:666: error: Incompatible types
in assignment (expression has type "float", variable has type "int") 
[assignment]
                    cumulative_volume += volume
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/pattern_engine.py:832: error: Returning Any from
function declared to return "float"  [no-any-return]
            return quality
            ^~~~~~~~~~~~~~
src/sensory/organs/dimensions/pattern_engine.py:839: error: Function is missing
a return type annotation  [no-untyped-def]
        def __init__(self):
        ^
src/sensory/organs/dimensions/pattern_engine.py:839: note: Use "-> None" if function does not return a value
src/ecosystem/optimization/ecosystem_optimizer.py:76: error: Return type
"Coroutine[Any, Any, dict[str, list[src.genome.models.genome.DecisionGenome]]]"
of "optimize_ecosystem" incompatible with return type
"Coroutine[Any, Any, Mapping[str, Sequence[src.core.interfaces.DecisionGenome]]]"
in supertype "src.core.interfaces.IEcosystemOptimizer"  [override]
        async def optimize_ecosystem(
        ^
src/ecosystem/optimization/ecosystem_optimizer.py:78: error: Argument 1 of
"optimize_ecosystem" is incompatible with supertype
"src.core.interfaces.IEcosystemOptimizer"; supertype defines the argument type
as "Mapping[str, Sequence[DecisionGenome]]"  [override]
            species_populations: Dict[str, List[CanonDecisionGenome]],
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/ecosystem/optimization/ecosystem_optimizer.py:78: note: This violates the Liskov substitution principle
src/ecosystem/optimization/ecosystem_optimizer.py:78: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
src/ecosystem/optimization/ecosystem_optimizer.py:201: error: Incompatible
types in assignment (expression has type "DecisionGenome | None", variable has
type "DecisionGenome")  [assignment]
                    child = scored_population[0][1] if scored_population e...
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/ecosystem/optimization/ecosystem_optimizer.py:440: error: Unused
"type: ignore" comment  [unused-ignore]
                return adapt_to_canonical(genome)  # type: ignore[arg-type...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/ecosystem/optimization/ecosystem_optimizer.py:520: error: Function is
missing a type annotation for one or more arguments  [no-untyped-def]
        def _calculate_regime_bonus(self, market_regime: str) -> float:
        ^
src/ecosystem/optimization/ecosystem_optimizer.py:531: error: Function is
missing a type annotation for one or more arguments  [no-untyped-def]
        def _calculate_adaptability_score(self, genome, market_data) -> fl...
        ^
src/ecosystem/optimization/ecosystem_optimizer.py:546: error: Returning Any
from function declared to return "float"  [no-any-return]
            return adaptability
            ^~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/integration_orchestrator.py:41: error:
Incompatible import of "ChaosAdaptationSystem" (imported name has type
"type[src.sensory.organs.dimensions.chaos_adaptation.ChaosAdaptationSystem]",
local name has type
"type[src.sensory.enhanced.chaos.antifragile_adaptation.ChaosAdaptationSystem]")
 [assignment]
    from src.sensory.organs.dimensions.chaos_adaptation import ChaosAdapta...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/sensory/organs/dimensions/integration_orchestrator.py:42: error:
Incompatible import of "InstitutionalFootprint" (imported name has type
"type[src.sensory.organs.dimensions.institutional_tracker.InstitutionalFootprint]",
local name has type
"type[src.sensory.enhanced.how.institutional_footprint_hunter.InstitutionalFootprint]")
 [assignment]
    from src.sensory.organs.dimensions.institutional_tracker import (
    ^
src/sensory/organs/dimensions/integration_orchestrator.py:42: error:
Incompatible import of "InstitutionalFootprintHunter" (imported name has type
"type[src.sensory.organs.dimensions.institutional_tracker.InstitutionalFootprintHunter]",
local name has type
"type[src.sensory.enhanced.how.institutional_footprint_hunter.InstitutionalFootprintHunter]")
 [assignment]
    from src.sensory.organs.dimensions.institutional_tracker import (
    ^
src/sensory/organs/dimensions/integration_orchestrator.py:50: error:
Incompatible import of "PatternSynthesis" (imported name has type
"type[src.sensory.organs.dimensions.pattern_engine.PatternSynthesis]", local
name has type
"type[src.sensory.enhanced.what.pattern_synthesis_engine.PatternSynthesis]") 
[assignment]
    from src.sensory.organs.dimensions.pattern_engine import (
    ^
src/sensory/organs/dimensions/integration_orchestrator.py:50: error:
Incompatible import of "PatternSynthesisEngine" (imported name has type
"type[src.sensory.organs.dimensions.pattern_engine.PatternSynthesisEngine]",
local name has type
"type[src.sensory.enhanced.what.pattern_synthesis_engine.PatternSynthesisEngine]")
 [assignment]
    from src.sensory.organs.dimensions.pattern_engine import (
    ^
src/sensory/organs/dimensions/integration_orchestrator.py:54: error:
Incompatible import of "TemporalAdvantage" (imported name has type
"type[src.sensory.organs.dimensions.temporal_system.TemporalAdvantage]", local
name has type
"type[src.sensory.enhanced.when.temporal_advantage_system.TemporalAdvantage]") 
[assignment]
    from src.sensory.organs.dimensions.temporal_system import (
    ^
src/sensory/organs/dimensions/integration_orchestrator.py:54: error:
Incompatible import of "TemporalAdvantageSystem" (imported name has type
"type[src.sensory.organs.dimensions.temporal_system.TemporalAdvantageSystem]",
local name has type
"type[src.sensory.enhanced.when.temporal_advantage_system.TemporalAdvantageSystem]")
 [assignment]
    from src.sensory.organs.dimensions.temporal_system import (
    ^
src/sensory/organs/dimensions/integration_orchestrator.py:431: error:
Unexpected keyword argument "order_blocks" for "InstitutionalFootprint" 
[call-arg]
            return InstitutionalFootprint(
                   ^
/home/dev/.local/lib/python3.12/site-packages/mypy/typeshed/stdlib/builtins.pyi:114: note: "InstitutionalFootprint" defined here
src/sensory/organs/dimensions/integration_orchestrator.py:431: error:
Unexpected keyword argument "fair_value_gaps" for "InstitutionalFootprint" 
[call-arg]
            return InstitutionalFootprint(
                   ^
src/sensory/organs/dimensions/integration_orchestrator.py:431: error:
Unexpected keyword argument "liquidity_sweeps" for "InstitutionalFootprint" 
[call-arg]
            return InstitutionalFootprint(
                   ^
src/sensory/organs/dimensions/integration_orchestrator.py:431: error:
Unexpected keyword argument "smart_money_flow" for "InstitutionalFootprint" 
[call-arg]
            return InstitutionalFootprint(
                   ^
src/sensory/organs/dimensions/integration_orchestrator.py:431: error:
Unexpected keyword argument "institutional_bias" for "InstitutionalFootprint" 
[call-arg]
            return InstitutionalFootprint(
                   ^
src/sensory/organs/dimensions/integration_orchestrator.py:431: error:
Unexpected keyword argument "confidence_score" for "InstitutionalFootprint" 
[call-arg]
            return InstitutionalFootprint(
                   ^
src/sensory/organs/dimensions/integration_orchestrator.py:431: error:
Unexpected keyword argument "market_structure" for "InstitutionalFootprint" 
[call-arg]
            return InstitutionalFootprint(
                   ^
src/sensory/organs/dimensions/integration_orchestrator.py:431: error:
Unexpected keyword argument "key_levels" for "InstitutionalFootprint" 
[call-arg]
            return InstitutionalFootprint(
                   ^
src/sensory/organs/dimensions/integration_orchestrator.py:444: error: Too many
arguments for "PatternSynthesis"  [call-arg]
            return PatternSynthesis([], [], {}, {}, 0.0, 0.1)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/integration_orchestrator.py:448: error: Too many
arguments for "TemporalAdvantage"  [call-arg]
            return TemporalAdvantage(0.0, {}, {}, "", (datetime.now(), dat...
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/thinking/ecosystem/specialized_predator_evolution.py:33: error: Module
"src.ecosystem.species.species_manager" has no attribute "SpeciesManager" 
[attr-defined]
    from src.ecosystem.species.species_manager import (
    ^
src/ecosystem/evolution/specialized_predator_evolution.py:102: error: Unused
"type: ignore" comment  [unused-ignore]
                optimization = await self.ecosystem_optimizer.get_ecosyste...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/ecosystem/evolution/specialized_predator_evolution.py:135: error: Unused
"type: ignore" comment  [unused-ignore]
                evolved_obj = await self.species_manager.evolve_specialist...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/thinking/phase3_orchestrator.py:230: error: Unsupported target for indexed
assignment ("object")  [index]
                    results['systems']['sentient'] = await self._run_senti...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/phase3_orchestrator.py:234: error: Unsupported target for indexed
assignment ("object")  [index]
                    results['systems']['predictive'] = await self._run_pre...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/phase3_orchestrator.py:238: error: Unsupported target for indexed
assignment ("object")  [index]
                    results['systems']['adversarial'] = await self._run_ad...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/phase3_orchestrator.py:242: error: Unsupported target for indexed
assignment ("object")  [index]
                    results['systems']['specialized'] = await self._run_sp...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/phase3_orchestrator.py:246: error: Unsupported target for indexed
assignment ("object")  [index]
                    results['systems']['competitive'] = await self._run_co...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/phase3_orchestrator.py:254: error: Incompatible types in
assignment (expression has type "datetime", variable has type "None") 
[assignment]
                self.last_full_analysis = analysis_start
                                          ^~~~~~~~~~~~~~
src/thinking/phase3_orchestrator.py:279: error: Argument 1 to "len" has
incompatible type "object"; expected "Sized"  [arg-type]
                    'adaptations_applied': len(adaptation_result.get('adap...
                                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~...
src/thinking/phase3_orchestrator.py:349: error: Argument 1 to "len" has
incompatible type "object"; expected "Sized"  [arg-type]
                        total_attacks += len(attacks)
                                             ^~~~~~~
src/thinking/phase3_orchestrator.py:350: error: Generator has incompatible item
type "int"; expected "bool"  [misc]
                        total_successes += sum(1 for a in attacks if isins...
                                               ^
src/thinking/phase3_orchestrator.py:350: error: "object" has no attribute
"__iter__"; maybe "__dir__" or "__str__"? (not iterable)  [attr-defined]
    ...               total_successes += sum(1 for a in attacks if isinstance...
                                                        ^~~~~~~
src/thinking/phase3_orchestrator.py:351: error: Argument 1 to "len" has
incompatible type "object"; expected "Sized"  [arg-type]
                        vuln_count += len(rpt.get("weaknesses_found", []))...
                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/phase3_orchestrator.py:426: error: Argument 1 to "len" has
incompatible type "object"; expected "Sized"  [arg-type]
                total = len(systems)
                            ^~~~~~~
src/thinking/phase3_orchestrator.py:427: error: "object" has no attribute
"values"  [attr-defined]
    ... = any(isinstance(v, dict) and 'error' in v for v in systems.values())
                                                            ^~~~~~~~~~~~~~
src/thinking/phase3_orchestrator.py:430: error: "object" has no attribute
"items"  [attr-defined]
                for name, v in systems.items():
                               ^~~~~~~~~~~~~
src/thinking/phase3_orchestrator.py:441: error: Unsupported right operand type
for in ("object")  [operator]
                    'sentient': 'sentient' in systems,
                                ^~~~~~~~~~~~~~~~~~~~~
src/thinking/phase3_orchestrator.py:442: error: Unsupported right operand type
for in ("object")  [operator]
                    'predictive': 'predictive' in systems,
                                  ^~~~~~~~~~~~~~~~~~~~~~~
src/thinking/phase3_orchestrator.py:443: error: Unsupported right operand type
for in ("object")  [operator]
                    'adversarial': 'adversarial' in systems,
                                   ^~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/phase3_orchestrator.py:444: error: Unsupported right operand type
for in ("object")  [operator]
                    'specialized': 'specialized' in systems,
                                   ^~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/phase3_orchestrator.py:445: error: Unsupported right operand type
for in ("object")  [operator]
                    'competitive': 'competitive' in systems,
                                   ^~~~~~~~~~~~~~~~~~~~~~~~
src/thinking/phase3_orchestrator.py:513: error: No overload variant of "int"
matches argument type "object"  [call-overload]
                        metrics['tick_count'] = int(metrics.get('tick_coun...
                                                ^~~~~~~~~~~~~~~~~~~~~~~~~~...
src/thinking/phase3_orchestrator.py:513: note: Possible overload variants:
src/thinking/phase3_orchestrator.py:513: note:     def __new__(cls, str | Buffer | SupportsInt | SupportsIndex | SupportsTrunc = ..., /) -> int
src/thinking/phase3_orchestrator.py:513: note:     def __new__(cls, str | bytes | bytearray, /, base: SupportsIndex) -> int
src/sensory/what/what_sensor.py:38: error: Missing type parameters for generic
type "dict"  [type-arg]
            patterns: dict = {}
                      ^
src/sensory/organs/dimensions/what_organ.py:45: error: Incompatible types in
assignment (expression has type "None", variable has type "PriceActionAnalyzer")
 [assignment]
                self.price_action = None
                                    ^~~~
src/sensory/organs/dimensions/what_organ.py:206: error: Unsupported operand
types for > ("Series[type[object]]" and "int")  [operator]
                higher_highs = (highs.diff() > 0).sum()
                                               ^
src/sensory/organs/dimensions/what_organ.py:207: error: Unsupported operand
types for > ("Series[type[object]]" and "int")  [operator]
                higher_lows = (lows.diff() > 0).sum()
                                             ^
src/sensory/organs/dimensions/what_organ.py:208: error: Unsupported operand
types for < ("Series[type[object]]" and "int")  [operator]
                lower_highs = (highs.diff() < 0).sum()
                                              ^
src/sensory/organs/dimensions/what_organ.py:209: error: Unsupported operand
types for < ("Series[type[object]]" and "int")  [operator]
                lower_lows = (lows.diff() < 0).sum()
                                            ^
src/sensory/organs/dimensions/what_organ.py:324: error: Unsupported operand
types for > ("Series[type[object]]" and "int")  [operator]
                higher_highs = (highs.diff() > 0).sum()
                                               ^
src/sensory/organs/dimensions/what_organ.py:325: error: Unsupported operand
types for > ("Series[type[object]]" and "int")  [operator]
                higher_lows = (lows.diff() > 0).sum()
                                             ^
src/sensory/organs/dimensions/what_organ.py:326: error: Unsupported operand
types for < ("Series[type[object]]" and "int")  [operator]
                lower_highs = (highs.diff() < 0).sum()
                                              ^
src/sensory/organs/dimensions/what_organ.py:327: error: Unsupported operand
types for < ("Series[type[object]]" and "int")  [operator]
                lower_lows = (lows.diff() < 0).sum()
                                            ^
src/sensory/organs/dimensions/what_organ.py:338: error: Returning Any from
function declared to return "float"  [no-any-return]
                return min(max(consistency, 0.0), 1.0)
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/what_organ.py:353: error: Returning Any from
function declared to return "float"  [no-any-return]
                return min(max(signal_strength, -1.0), 1.0)
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/what_organ.py:370: error: Returning Any from
function declared to return "float"  [no-any-return]
                return min(max(base_confidence, 0.0), 1.0)
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/sensory/organs/dimensions/what_organ.py:389: error: "MarketData" has no
attribute "spread"  [attr-defined]
                    'spread': md.spread,
                              ^~~~~~~~~
src/sensory/organs/dimensions/what_organ.py:390: error: "MarketData" has no
attribute "mid_price"  [attr-defined]
                    'mid_price': md.mid_price
                                 ^~~~~~~~~~~~
src/validation/validation_framework.py:27: error: Function is missing a return
type annotation  [no-untyped-def]
        def __init__(self):
        ^
src/validation/validation_framework.py:27: note: Use "-> None" if function does not return a value
src/validation/validation_framework.py:28: error: Missing type parameters for
generic type "Callable"  [type-arg]
            self.validators: Dict[str, Callable] = {}
                                       ^
src/validation/validation_framework.py:56: error: Missing positional arguments
"strategy_id", "symbols", "params" in call to "MovingAverageStrategy" 
[call-arg]
                    strategy = MovingAverageStrategy()
                               ^~~~~~~~~~~~~~~~~~~~~~~
src/validation/validation_framework.py:412: error: Function is missing a return
type annotation  [no-untyped-def]
    async def main():
    ^
src/validation/validation_framework.py:412: note: Use "-> None" if function does not return a value
src/integration/component_integrator_impl.py:97: error: Module
"src.core.risk.manager" has no attribute "RiskConfig"  [attr-defined]
                from src.core.risk.manager import RiskConfig, RiskManager
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Found 707 errors in 84 files (checked 342 source files)
