from __future__ import annotations

import argparse
from datetime import UTC, datetime
from pathlib import Path
from typing import Sequence

from .ci_metrics import (
    DEFAULT_METRICS_PATH,
    record_coverage,
    record_coverage_domains,
    record_formatter,
)


def _timestamp() -> str:
    return datetime.now(tz=UTC).isoformat(timespec="seconds")


def _build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description="Update CI telemetry trendlines for coverage and formatter adoption.",
    )
    parser.add_argument(
        "--metrics",
        type=Path,
        default=DEFAULT_METRICS_PATH,
        help="Path to the CI metrics JSON file (defaults to tests/.telemetry/ci_metrics.json)",
    )
    parser.add_argument(
        "--coverage-report",
        type=Path,
        help="Path to a coverage XML report generated by coverage.py/pytest --cov",
    )
    parser.add_argument(
        "--coverage-label",
        type=str,
        help="Label to associate with the recorded coverage entry (defaults to UTC timestamp)",
    )
    parser.add_argument(
        "--no-domain-breakdown",
        action="store_true",
        help="Skip recording per-domain coverage snapshots when recording coverage",
    )
    parser.add_argument(
        "--domain-threshold",
        type=float,
        default=80.0,
        help="Threshold for flagging lagging domains in coverage telemetry",
    )
    parser.add_argument(
        "--allowlist",
        type=Path,
        help="Path to the Ruff formatter allowlist file (deprecated once formatter mode is global)",
    )
    parser.add_argument(
        "--formatter-mode",
        choices=["global", "allowlist"],
        help="Record a formatter trend entry using the specified enforcement mode",
    )
    parser.add_argument(
        "--formatter-label",
        type=str,
        help="Label for the formatter trend entry (defaults to UTC timestamp)",
    )
    return parser


def main(argv: Sequence[str] | None = None) -> int:
    parser = _build_parser()
    args = parser.parse_args(argv)

    formatter_mode: str | None = args.formatter_mode
    if formatter_mode is None and args.allowlist is not None:
        formatter_mode = "allowlist"

    if args.coverage_report is None and formatter_mode is None:
        parser.error("Provide --coverage-report, --formatter-mode, or both to update metrics")

    metrics_data = None
    metrics_path: Path = args.metrics

    if args.coverage_report is not None:
        coverage_label = args.coverage_label or _timestamp()
        metrics_data = record_coverage(
            metrics_path,
            args.coverage_report,
            label=coverage_label,
            data=metrics_data,
        )
        if not args.no_domain_breakdown:
            metrics_data = record_coverage_domains(
                metrics_path,
                args.coverage_report,
                label=coverage_label,
                threshold=args.domain_threshold,
                data=metrics_data,
            )

    if formatter_mode is not None:
        if formatter_mode == "allowlist" and args.allowlist is None:
            parser.error("--allowlist is required when --formatter-mode=allowlist")
        if formatter_mode != "allowlist" and args.allowlist is not None:
            parser.error("Do not supply --allowlist when formatter mode is global")

        formatter_label = args.formatter_label or _timestamp()
        metrics_data = record_formatter(
            metrics_path,
            args.allowlist if formatter_mode == "allowlist" else None,
            mode=formatter_mode,
            label=formatter_label,
            data=metrics_data,
        )

    return 0


if __name__ == "__main__":  # pragma: no cover - CLI entry point
    raise SystemExit(main())
